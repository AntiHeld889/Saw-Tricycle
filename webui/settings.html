<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Einstellungen · Saw Tricycle</title>
  <style>
    :root {
      color-scheme: dark;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #0d0d0d;
      color: #f2f2f2;
      margin: 0;
      min-height: 100vh;
      min-height: 100dvh;
      padding: calc(1.4rem + var(--safe-top)) calc(1.4rem + var(--safe-right)) calc(1.4rem + var(--safe-bottom)) calc(1.4rem + var(--safe-left));
      display: flex;
      justify-content: center;
      align-items: center;
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }
    .settings-card {
      width: 100%;
      max-width: 520px;
      background: #151515;
      border-radius: 16px;
      padding: clamp(1.2rem, 4vw + 0.4rem, 1.8rem);
      box-shadow: 0 0 40px rgba(0,0,0,0.45);
      display: flex;
      flex-direction: column;
      gap: 1.4rem;
    }
    .settings-header {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .back-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 42px;
      height: 42px;
      border-radius: 12px;
      background: rgba(229,9,20,0.16);
      border: 1px solid rgba(229,9,20,0.3);
      color: #fff;
      text-decoration: none;
      transition: background 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
    }
    .back-button:hover {
      background: rgba(229,9,20,0.28);
      border-color: rgba(229,9,20,0.55);
    }
    .back-button:active {
      transform: translateY(1px);
    }
    .settings-header h1 {
      margin: 0;
      font-size: clamp(1.25rem, 3vw, 1.7rem);
      font-weight: 600;
    }
    .settings-section {
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }
    .settings-section h2 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }
    label { font-size: 0.95rem; }
    select {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.12);
      color: #fff;
      padding: 0.55rem 0.75rem;
      border-radius: 12px;
      font-size: 0.95rem;
      min-height: 44px;
    }
    select:focus {
      outline: none;
      border-color: rgba(229,9,20,0.55);
      box-shadow: 0 0 0 3px rgba(229,9,20,0.2);
    }
    .audio-volume {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 0.9rem;
    }
    .text-input {
      display: flex;
      align-items: center;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 0.45rem 0.6rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .text-input:focus-within {
      border-color: rgba(229,9,20,0.55);
      box-shadow: 0 0 0 3px rgba(229,9,20,0.2);
    }
    .text-input input {
      flex: 1 1 auto;
      background: transparent;
      border: none;
      color: inherit;
      font: inherit;
      padding: 0;
      min-width: 0;
    }
    .text-input input:focus {
      outline: none;
    }
    .text-input input::placeholder {
      color: rgba(255,255,255,0.45);
    }
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
    }
    .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.55rem 1.1rem;
      border-radius: 12px;
      border: 1px solid rgba(229,9,20,0.4);
      background: rgba(229,9,20,0.16);
      color: #fff;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    .button:hover:not(:disabled) {
      background: rgba(229,9,20,0.28);
      border-color: rgba(229,9,20,0.55);
    }
    .button:active:not(:disabled) {
      transform: translateY(1px);
    }
    .button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .sound-row {
      display: flex;
      gap: 0.6rem;
      align-items: center;
    }
    .sound-row select {
      flex: 1 1 auto;
    }
    .file-upload-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
    }
    .file-upload-row input[type="file"] {
      flex: 1 1 220px;
      min-width: 0;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.12);
      color: #fff;
      padding: 0.45rem 0.6rem;
      border-radius: 12px;
      cursor: pointer;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .file-upload-row input[type="file"]:focus {
      outline: none;
      border-color: rgba(229,9,20,0.55);
      box-shadow: 0 0 0 3px rgba(229,9,20,0.2);
    }
    .file-upload-row input[type="file"]:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      border-color: rgba(255,255,255,0.12);
    }
    .file-upload-row input[type="file"]::file-selector-button {
      margin-right: 0.75rem;
      padding: 0.35rem 0.9rem;
      border-radius: 10px;
      border: 1px solid rgba(229,9,20,0.4);
      background: rgba(229,9,20,0.16);
      color: #fff;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    .file-upload-row input[type="file"]::file-selector-button:hover:not(:disabled) {
      background: rgba(229,9,20,0.28);
      border-color: rgba(229,9,20,0.55);
    }
    .file-upload-row input[type="file"]::file-selector-button:active:not(:disabled) {
      transform: translateY(1px);
    }
    .file-upload-row input[type="file"]::file-selector-button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }
    .button-actions {
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }
    .button-action {
      gap: 0.45rem;
    }
    .button-action-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
    }
    .button-action-row [hidden] {
      display: none !important;
    }
    .button-action-row select,
    .button-action-row .text-input {
      flex: 1 1 180px;
    }
    .button-action-row select.button-action-mode {
      flex: 0 0 180px;
      min-width: 150px;
    }
    .button-action-mp3 {
      flex: 1 1 220px;
    }
    .button-action-mp3 select {
      width: 100%;
    }
    .button-action-command {
      flex: 1 1 220px;
    }
    .button-action-command input {
      width: 100%;
    }
    .sound-preview-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid rgba(229,9,20,0.4);
      background: rgba(229,9,20,0.12);
      color: #fff;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    .sound-preview-button:hover:not(:disabled) {
      background: rgba(229,9,20,0.24);
      border-color: rgba(229,9,20,0.55);
    }
    .sound-preview-button:active:not(:disabled) {
      transform: translateY(1px);
    }
    .sound-preview-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .sound-preview-button span[aria-hidden="true"] {
      font-size: 1rem;
      line-height: 1;
    }
    input[type="range"] {
      width: 100%;
      accent-color: #e50914;
    }
    output {
      min-width: 3ch;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .settings-section p.hint {
      margin: 0;
      color: #bbb;
      font-size: 0.9rem;
    }
    .status-container {
      border-radius: 12px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 0.75rem 1rem;
      font-size: 0.95rem;
      color: #bbb;
    }
    .status-container + .settings-section {
      margin-top: -0.2rem;
    }
    .status {
      margin: 0;
      min-height: 1.2em;
    }
    .status.success { color: #63f58c; }
    .status.error { color: #ff7a7a; }
    .settings-footer {
      display: flex;
      justify-content: flex-end;
    }
    .more-settings-link {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.55rem 1.1rem;
      border-radius: 12px;
      background: rgba(229,9,20,0.16);
      border: 1px solid rgba(229,9,20,0.4);
      color: #fff;
      font-size: 0.95rem;
      font-weight: 600;
      text-decoration: none;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    .more-settings-link:hover {
      background: rgba(229,9,20,0.28);
      border-color: rgba(229,9,20,0.55);
    }
    .more-settings-link:active {
      transform: translateY(1px);
    }
    @media (max-width: 640px) {
      body {
        padding: calc(1rem + var(--safe-top)) calc(1rem + var(--safe-right)) calc(1rem + var(--safe-bottom)) calc(1rem + var(--safe-left));
      }
      .settings-card {
        border-radius: 12px;
      }
    }
    @media (orientation: landscape) and (max-height: 520px) {
      body {
        padding: calc(0.7rem + var(--safe-top)) calc(0.75rem + var(--safe-right)) calc(0.7rem + var(--safe-bottom)) calc(0.75rem + var(--safe-left));
        align-items: stretch;
      }
      .settings-card {
        padding: 0.95rem;
        gap: 1rem;
        max-height: calc(100dvh - var(--safe-top) - var(--safe-bottom) - 1.2rem);
        overflow-y: auto;
        overscroll-behavior: contain;
      }
      .settings-section {
        padding: 1rem;
        gap: 0.75rem;
      }
      .slider-row {
        gap: 0.7rem;
      }
    }
    @media (orientation: landscape) and (max-height: 430px) {
      body {
        padding: calc(0.6rem + var(--safe-top)) calc(0.65rem + var(--safe-right)) calc(0.6rem + var(--safe-bottom)) calc(0.65rem + var(--safe-left));
      }
      .settings-card {
        padding: 0.8rem;
        gap: 0.85rem;
      }
      .settings-section {
        padding: 0.85rem;
      }
      .slider-row {
        gap: 0.6rem;
      }
    }
    @media (max-width: 420px) {
      .sound-preview-button {
        width: 42px;
        height: 42px;
      }
    }
  </style>
</head>
<body>
  <div class="settings-card">
    <div class="settings-header">
      <a class="back-button" href="/" aria-label="Zurück zur Steuerung" title="Zurück">⟵</a>
      <h1>Einstellungen</h1>
    </div>
    <div class="status-container" role="status" aria-live="polite">
      <p id="status" class="status"></p>
    </div>
    <section class="settings-section">
      <h2>Audio-Ausgabe</h2>
      <div class="audio-output">
        <label for="audioDevice">Ausgabegerät auswählen</label>
        <select id="audioDevice" aria-label="Audio-Ausgabe auswählen"></select>
      </div>
      <div class="audio-volume" id="audioVolumeContainer" hidden>
        <label for="audioVolume">Lautstärke</label>
        <div class="slider-row">
          <input id="audioVolume" type="range" min="0" max="100" step="1" aria-label="Lautstärke einstellen">
          <output id="audioVolumeValue" for="audioVolume">0%</output>
        </div>
      </div>
    </section>
    <section class="settings-section">
      <h2>Sounds</h2>
      <div class="field">
        <label for="soundDirectory">MP3-Verzeichnis</label>
        <div class="text-input">
          <input id="soundDirectory" type="text" inputmode="text" autocomplete="off" placeholder="z. B. /home/pi/Musik" aria-label="Pfad zum MP3-Verzeichnis">
        </div>
        <div class="button-row">
          <button type="button" class="button" id="soundDirectorySave">Pfad speichern</button>
        </div>
        <p class="hint">Alle MP3-Dateien aus diesem Ordner stehen für Sounds zur Auswahl.</p>
      </div>
      <div class="field">
        <label for="soundUpload">Eigene MP3 hinzufügen</label>
        <div class="file-upload-row">
          <input id="soundUpload" type="file" accept=".mp3,audio/mpeg" aria-label="MP3-Datei auswählen">
          <button type="button" class="button" id="soundUploadButton">MP3 hochladen</button>
        </div>
        <p class="hint">Unterstützt MP3-Dateien bis 20&nbsp;MB. Die Datei wird im gewählten Verzeichnis gespeichert.</p>
      </div>
      <div class="field">
        <label for="connectedSound">Connected Sound</label>
        <div class="sound-row">
          <select id="connectedSound" aria-label="Connected Sound auswählen"></select>
          <button type="button" class="sound-preview-button" data-sound-preview="connected" aria-label="Connected Sound probehören">
            <span aria-hidden="true">▶</span>
          </button>
        </div>
        <p class="hint">Wird nach erfolgreicher Controller-Verbindung abgespielt.</p>
      </div>
      <div class="field">
        <label for="startupSound">Start-Up-Sound</label>
        <div class="sound-row">
          <select id="startupSound" aria-label="Start-Up-Sound auswählen"></select>
          <button type="button" class="sound-preview-button" data-sound-preview="startup" aria-label="Start-Up-Sound probehören">
            <span aria-hidden="true">▶</span>
          </button>
        </div>
        <p class="hint">Wird beim Programmstart abgespielt.</p>
      </div>
    </section>
    <section class="settings-section">
      <h2>Weblinks</h2>
      <div class="field">
        <label for="webPort">Webserver-Port</label>
        <div class="text-input">
          <input id="webPort" type="text" inputmode="numeric" pattern="[0-9]*" autocomplete="off" placeholder="8081" aria-label="Port für den Saw Tricycle Webserver">
        </div>
        <div class="button-row">
          <button type="button" class="button" id="webPortSave">Port speichern</button>
        </div>
        <p class="hint">Wirksam nach Neustart der Anwendung.</p>
      </div>
      <div class="field">
        <label for="soundboardPort">Soundboard URL PORT</label>
        <div class="text-input">
          <input id="soundboardPort" type="text" inputmode="numeric" pattern="[0-9]*" autocomplete="off" placeholder="3000" aria-label="Port für das Soundboard">
        </div>
        <div class="button-row">
          <button type="button" class="button" id="soundboardPortSave">Port speichern</button>
        </div>
      </div>
      <div class="field">
        <label for="cameraPort">Kamera Port/Pfad</label>
        <div class="text-input">
          <input id="cameraPort" type="text" autocomplete="off" placeholder="8080/cam" aria-label="Port und optionaler Pfad für die Kamera">
        </div>
        <div class="button-row">
          <button type="button" class="button" id="cameraPortSave">Adresse speichern</button>
        </div>
      </div>
      <div class="field">
        <label for="lightLink">Lichtsteuerung URL</label>
        <div class="text-input">
          <input id="lightLink" type="text" autocomplete="off" placeholder="http://192.168.0.50" aria-label="URL für die Lichtsteuerung">
        </div>
        <div class="button-row">
          <button type="button" class="button" id="lightLinkSave">Adresse speichern</button>
        </div>
        <p class="hint">Wird über das Glühbirnen-Icon auf der Startseite geöffnet.</p>
      </div>
    </section>
    <section class="settings-section">
      <h2>Gamepad-Tasten</h2>
      <p class="hint">Wähle pro Taste eine MP3 aus oder hinterlege einen Raspberry&nbsp;Pi Befehl.</p>
      <div id="buttonActionsContainer" class="button-actions" aria-live="polite"></div>
      <div class="field">
        <label for="disconnectCommand">Befehl bei Gamepad-Verlust</label>
        <div class="text-input">
          <input id="disconnectCommand" type="text" inputmode="text" autocomplete="off" placeholder="sudo systemctl restart ..." aria-label="Befehl, der bei Gamepad-Trennung ausgeführt wird">
        </div>
        <div class="button-row">
          <button type="button" class="button" id="disconnectCommandSave">Befehl speichern</button>
        </div>
        <p class="hint">Wird ausgeführt, sobald die Verbindung zum Gamepad abbricht.</p>
      </div>
    </section>
    <div class="settings-footer">
      <a class="more-settings-link" href="/more-settings" aria-label="Weitere Einstellungen öffnen">Weitere Einstellungen</a>
    </div>
    <audio id="soundPreviewPlayer" preload="none" hidden></audio>
  </div>
  <script>
    const audioSelect = document.getElementById('audioDevice');
    const statusEl = document.getElementById('status');
    const volumeContainer = document.getElementById('audioVolumeContainer');
    const volumeSlider = document.getElementById('audioVolume');
    const volumeValue = document.getElementById('audioVolumeValue');
    const motorForward = document.getElementById('motorForward');
    const motorReverse = document.getElementById('motorReverse');
    const motorForwardValue = document.getElementById('motorForwardValue');
    const motorReverseValue = document.getElementById('motorReverseValue');
    const soundDirectoryInput = document.getElementById('soundDirectory');
    const soundDirectorySave = document.getElementById('soundDirectorySave');
    const webPortInput = document.getElementById('webPort');
    const webPortSave = document.getElementById('webPortSave');
    const soundboardPortInput = document.getElementById('soundboardPort');
    const soundboardPortSave = document.getElementById('soundboardPortSave');
    const cameraPortInput = document.getElementById('cameraPort');
    const cameraPortSave = document.getElementById('cameraPortSave');
    const lightLinkInput = document.getElementById('lightLink');
    const lightLinkSave = document.getElementById('lightLinkSave');
    const connectedSoundSelect = document.getElementById('connectedSound');
    const connectedSoundPreviewButton = document.querySelector('[data-sound-preview="connected"]');
    const startupSoundSelect = document.getElementById('startupSound');
    const startupSoundPreviewButton = document.querySelector('[data-sound-preview="startup"]');
    const soundUploadInput = document.getElementById('soundUpload');
    const soundUploadButton = document.getElementById('soundUploadButton');
    const soundPreviewPlayer = document.getElementById('soundPreviewPlayer');
    const buttonActionsContainer = document.getElementById('buttonActionsContainer');
    const disconnectCommandInput = document.getElementById('disconnectCommand');
    const disconnectCommandSave = document.getElementById('disconnectCommandSave');
    const BUTTON_MODE_NONE = 'none';
    const BUTTON_MODE_MP3 = 'mp3';
    const BUTTON_MODE_COMMAND = 'command';
    const SOUND_UPLOAD_MAX_BYTES = 20 * 1024 * 1024;
    const buttonActionControls = new Map();
    let buttonAssignments = {};
    let buttonDefinitions = [];
    let currentSoundFiles = [];
    let soundDirectoryConfigured = false;
    let syncingButtonActions = false;
    let soundUploadInProgress = false;
    audioSelect.disabled = true;
    let audioOptionsSignature = '';
    let volumeConfig = null;
    let motorConfig = null;
    if (volumeSlider) {
      volumeSlider.disabled = true;
    }
    if (volumeContainer) {
      volumeContainer.hidden = true;
    }
    if (motorForward) {
      motorForward.disabled = true;
      motorForward.value = '0';
    }
    if (motorReverse) {
      motorReverse.disabled = true;
      motorReverse.value = '0';
    }
    if (motorForwardValue) {
      motorForwardValue.textContent = '–';
    }
    if (motorReverseValue) {
      motorReverseValue.textContent = '–';
    }
    if (soundDirectoryInput) {
      soundDirectoryInput.disabled = true;
      soundDirectoryInput.value = '';
    }
    if (soundDirectorySave) {
      soundDirectorySave.disabled = true;
    }
    if (webPortInput) {
      webPortInput.disabled = true;
      webPortInput.value = '';
    }
    if (webPortSave) {
      webPortSave.disabled = true;
    }
    if (soundboardPortInput) {
      soundboardPortInput.disabled = true;
      soundboardPortInput.value = '';
    }
    if (soundboardPortSave) {
      soundboardPortSave.disabled = true;
    }
    if (cameraPortInput) {
      cameraPortInput.disabled = true;
      cameraPortInput.value = '';
    }
    if (cameraPortSave) {
      cameraPortSave.disabled = true;
    }
    if (lightLinkInput) {
      lightLinkInput.disabled = true;
      lightLinkInput.value = '';
    }
    if (lightLinkSave) {
      lightLinkSave.disabled = true;
    }
    if (connectedSoundSelect) {
      connectedSoundSelect.disabled = true;
    }
    if (connectedSoundPreviewButton) {
      connectedSoundPreviewButton.disabled = true;
    }
    if (startupSoundSelect) {
      startupSoundSelect.disabled = true;
    }
    if (startupSoundPreviewButton) {
      startupSoundPreviewButton.disabled = true;
    }
    if (soundUploadInput) {
      soundUploadInput.disabled = true;
      soundUploadInput.value = '';
    }
    if (soundUploadButton) {
      soundUploadButton.disabled = true;
    }
    if (disconnectCommandInput) {
      disconnectCommandInput.disabled = true;
      disconnectCommandInput.value = '';
    }
    if (disconnectCommandSave) {
      disconnectCommandSave.disabled = true;
    }
    const updatePreviewButtonState = () => {
      const hasPreviewPlayer = Boolean(soundPreviewPlayer);
      if (connectedSoundPreviewButton) {
        const disabled =
          !hasPreviewPlayer
          || !connectedSoundSelect
          || connectedSoundSelect.disabled
          || !connectedSoundSelect.value;
        connectedSoundPreviewButton.disabled = disabled;
      }
      if (startupSoundPreviewButton) {
        const disabled =
          !hasPreviewPlayer
          || !startupSoundSelect
          || startupSoundSelect.disabled
          || !startupSoundSelect.value;
        startupSoundPreviewButton.disabled = disabled;
      }
      buttonActionControls.forEach((controls) => {
        if (!controls || !controls.mp3PreviewButton) {
          return;
        }
        const disabled =
          !hasPreviewPlayer
          || !controls.mp3Wrapper
          || controls.mp3Wrapper.hidden
          || !controls.mp3Select
          || controls.mp3Select.disabled
          || !controls.mp3Select.value;
        controls.mp3PreviewButton.disabled = disabled;
      });
    };
    updatePreviewButtonState();
    const updateSoundUploadAvailability = () => {
      if (!soundUploadInput || !soundUploadButton) {
        return;
      }
      if (soundUploadInProgress) {
        soundUploadInput.disabled = true;
        soundUploadButton.disabled = true;
        return;
      }
      const hasDirectory = soundDirectoryConfigured;
      const hasFile = Boolean(soundUploadInput.files && soundUploadInput.files.length > 0);
      soundUploadInput.disabled = !hasDirectory;
      if (!hasDirectory && soundUploadInput.value) {
        soundUploadInput.value = '';
      }
      soundUploadButton.disabled = !hasDirectory || !hasFile;
    };
    updateSoundUploadAvailability();
    if (soundPreviewPlayer) {
      soundPreviewPlayer.addEventListener('error', (event) => {
        console.error('Sound-Vorschau fehlgeschlagen', event);
        setStatus('Sound konnte nicht abgespielt werden.', 'error');
      });
    }

    const buildButtonActionsUI = (definitions) => {
      if (!buttonActionsContainer) {
        return;
      }
      buttonActionControls.clear();
      buttonActionsContainer.innerHTML = '';
      if (!Array.isArray(definitions) || definitions.length === 0) {
        const empty = document.createElement('p');
        empty.className = 'hint';
        empty.textContent = 'Keine konfigurierbaren Tasten gefunden.';
        buttonActionsContainer.append(empty);
        updatePreviewButtonState();
        return;
      }
      const fragment = document.createDocumentFragment();
      definitions.forEach((definition) => {
        const code = typeof definition.code === 'string' ? definition.code : '';
        if (!code) {
          return;
        }
        const label = typeof definition.label === 'string' && definition.label ? definition.label : code;
        const field = document.createElement('div');
        field.className = 'field button-action';
        field.dataset.code = code;
        const labelEl = document.createElement('label');
        labelEl.textContent = label;
        field.append(labelEl);
        const row = document.createElement('div');
        row.className = 'button-action-row';
        const modeSelect = document.createElement('select');
        modeSelect.className = 'button-action-mode';
        modeSelect.setAttribute('aria-label', `${label} Aktion`);
        const optionNone = document.createElement('option');
        optionNone.value = BUTTON_MODE_NONE;
        optionNone.textContent = 'Keine Aktion';
        modeSelect.append(optionNone);
        const optionMp3 = document.createElement('option');
        optionMp3.value = BUTTON_MODE_MP3;
        optionMp3.textContent = 'MP3 abspielen';
        modeSelect.append(optionMp3);
        const optionCommand = document.createElement('option');
        optionCommand.value = BUTTON_MODE_COMMAND;
        optionCommand.textContent = 'Befehl ausführen';
        modeSelect.append(optionCommand);
        row.append(modeSelect);
        const mp3Wrapper = document.createElement('div');
        mp3Wrapper.className = 'button-action-mp3 sound-row';
        const mp3Select = document.createElement('select');
        mp3Select.setAttribute('aria-label', `${label} MP3 auswählen`);
        mp3Wrapper.append(mp3Select);
        const mp3PreviewButton = document.createElement('button');
        mp3PreviewButton.type = 'button';
        mp3PreviewButton.className = 'sound-preview-button';
        mp3PreviewButton.setAttribute('aria-label', `${label} MP3 probehören`);
        const mp3PreviewIcon = document.createElement('span');
        mp3PreviewIcon.setAttribute('aria-hidden', 'true');
        mp3PreviewIcon.textContent = '▶';
        mp3PreviewButton.append(mp3PreviewIcon);
        mp3PreviewButton.disabled = true;
        mp3Wrapper.append(mp3PreviewButton);
        row.append(mp3Wrapper);
        const commandWrapper = document.createElement('div');
        commandWrapper.className = 'text-input button-action-command';
        const commandInput = document.createElement('input');
        commandInput.type = 'text';
        commandInput.autocomplete = 'off';
        commandInput.placeholder = 'sudo …';
        commandInput.setAttribute('aria-label', `${label} Befehl`);
        commandWrapper.append(commandInput);
        row.append(commandWrapper);
        mp3Wrapper.hidden = true;
        commandWrapper.hidden = true;
        field.append(row);
        fragment.append(field);
        buttonActionControls.set(code, {
          container: field,
          modeSelect,
          mp3Wrapper,
          mp3Select,
          mp3PreviewButton,
          mp3Option: optionMp3,
          commandWrapper,
          commandInput,
        });

        mp3PreviewButton.addEventListener('click', () => {
          playSoundPreview(mp3Select, mp3PreviewButton);
        });

        modeSelect.addEventListener('change', () => {
          if (syncingButtonActions) {
            return;
          }
          const selectedMode = modeSelect.value;
          const controls = buttonActionControls.get(code);
          if (!controls) {
            return;
          }
          if (selectedMode === BUTTON_MODE_MP3) {
            controls.mp3Wrapper.hidden = false;
            controls.commandWrapper.hidden = true;
            const value = controls.mp3Select.value;
            if (value) {
              saveButtonAction(code, BUTTON_MODE_MP3, value);
            } else {
              saveButtonAction(code, BUTTON_MODE_NONE, '');
            }
          } else if (selectedMode === BUTTON_MODE_COMMAND) {
            controls.mp3Wrapper.hidden = true;
            controls.commandWrapper.hidden = false;
            controls.commandInput.focus();
            const trimmed = controls.commandInput.value.trim();
            if (trimmed) {
              saveButtonAction(code, BUTTON_MODE_COMMAND, trimmed);
            } else {
              saveButtonAction(code, BUTTON_MODE_NONE, '');
            }
          } else {
            controls.mp3Wrapper.hidden = true;
            controls.commandWrapper.hidden = true;
            saveButtonAction(code, BUTTON_MODE_NONE, '');
          }
          updatePreviewButtonState();
        });

        mp3Select.addEventListener('change', () => {
          if (syncingButtonActions) {
            return;
          }
          const value = mp3Select.value;
          if (value) {
            saveButtonAction(code, BUTTON_MODE_MP3, value);
          } else {
            saveButtonAction(code, BUTTON_MODE_NONE, '');
          }
          updatePreviewButtonState();
        });

        const handleCommandSave = () => {
          if (syncingButtonActions) {
            return;
          }
          const trimmed = commandInput.value.trim();
          if (trimmed) {
            saveButtonAction(code, BUTTON_MODE_COMMAND, trimmed);
          } else {
            saveButtonAction(code, BUTTON_MODE_NONE, '');
          }
        };
        commandInput.addEventListener('change', handleCommandSave);
        commandInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            handleCommandSave();
          }
        });
      });
      buttonActionsContainer.append(fragment);
      updatePreviewButtonState();
    };

    const applyButtonActionToControls = (code, assignment) => {
      const controls = buttonActionControls.get(code);
      if (!controls) {
        return;
      }
      const mode = assignment && typeof assignment.mode === 'string'
        ? assignment.mode.toLowerCase()
        : BUTTON_MODE_NONE;
      const value = assignment && typeof assignment.value === 'string' ? assignment.value : '';
      const normalizedMode = [
        BUTTON_MODE_NONE,
        BUTTON_MODE_MP3,
        BUTTON_MODE_COMMAND,
      ].includes(mode)
        ? mode
        : BUTTON_MODE_NONE;
      const mp3Available = soundDirectoryConfigured && Array.isArray(currentSoundFiles) && currentSoundFiles.length > 0;
      syncingButtonActions = true;
      if (controls.mp3Option) {
        controls.mp3Option.disabled = !mp3Available;
      }
      const appliedMode = !mp3Available && normalizedMode === BUTTON_MODE_MP3 ? BUTTON_MODE_NONE : normalizedMode;
      controls.modeSelect.value = appliedMode;
      controls.mp3Wrapper.hidden = appliedMode !== BUTTON_MODE_MP3;
      controls.commandWrapper.hidden = appliedMode !== BUTTON_MODE_COMMAND;
      if (normalizedMode === BUTTON_MODE_COMMAND) {
        controls.commandInput.value = value || '';
      } else if (!controls.commandInput.value) {
        controls.commandInput.value = value || '';
      }
      if (appliedMode !== BUTTON_MODE_MP3) {
        controls.mp3Select.value = '';
      }
      syncingButtonActions = false;
      updatePreviewButtonState();
    };

    const updateButtonMp3Options = () => {
      if (buttonActionControls.size === 0) {
        return;
      }
      buttonActionControls.forEach((controls, code) => {
        const select = controls.mp3Select;
        if (!select) {
          return;
        }
        const fileList = Array.isArray(currentSoundFiles) ? currentSoundFiles : [];
        const mp3Available = soundDirectoryConfigured && fileList.length > 0;
        while (select.firstChild) {
          select.removeChild(select.firstChild);
        }
        if (controls.mp3Option) {
          controls.mp3Option.disabled = !mp3Available;
        }
        if (fileList.length === 0) {
          const option = document.createElement('option');
          option.value = '';
          option.textContent = soundDirectoryConfigured
            ? 'Keine MP3-Dateien gefunden'
            : 'Kein MP3-Verzeichnis konfiguriert';
          select.append(option);
          select.disabled = true;
        } else {
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = 'MP3 auswählen';
          select.append(placeholder);
          fileList.forEach((file) => {
            const option = document.createElement('option');
            option.value = file;
            option.textContent = file;
            select.append(option);
          });
          const assignment = buttonAssignments[code];
          const target = assignment && assignment.mode === BUTTON_MODE_MP3 && assignment.value
            ? assignment.value
            : '';
          if (target) {
            const normalized = fileList.find((file) => file.toLowerCase() === target.toLowerCase());
            if (!normalized) {
              const missing = document.createElement('option');
              missing.value = target;
              missing.textContent = `${target} (nicht gefunden)`;
              missing.disabled = true;
              select.append(missing);
            }
          }
          select.disabled = false;
        }
        const assignment = buttonAssignments[code];
        const targetValue = assignment && assignment.mode === BUTTON_MODE_MP3 && assignment.value
          ? assignment.value
          : '';
        const normalized = targetValue
          ? fileList.find((file) => file.toLowerCase() === targetValue.toLowerCase()) || targetValue
          : '';
        syncingButtonActions = true;
        select.value = normalized || '';
        syncingButtonActions = false;
      });
      updatePreviewButtonState();
    };

    const syncButtonActions = (info) => {
      if (!buttonActionsContainer) {
        return null;
      }
      if (!info || !Array.isArray(info.definitions)) {
        buttonDefinitions = [];
        buttonAssignments = {};
        buttonActionControls.clear();
        buttonActionsContainer.innerHTML = '';
        updatePreviewButtonState();
        return null;
      }
      const normalizedDefinitions = info.definitions
        .map((item) => {
          const code = typeof item.code === 'string' ? item.code : '';
          const label = typeof item.label === 'string' && item.label ? item.label : code;
          return { code, label };
        })
        .filter((item) => item.code);
      const definitionsChanged =
        normalizedDefinitions.length !== buttonDefinitions.length
        || normalizedDefinitions.some((definition, index) => {
          const previous = buttonDefinitions[index];
          if (!previous) {
            return true;
          }
          return definition.code !== previous.code || definition.label !== previous.label;
        });
      if (definitionsChanged) {
        buildButtonActionsUI(normalizedDefinitions);
      }
      buttonDefinitions = normalizedDefinitions;
      const assignmentsRaw = info.assignments && typeof info.assignments === 'object' ? info.assignments : {};
      const nextAssignments = {};
      buttonDefinitions.forEach((definition) => {
        const code = definition.code;
        const entry = assignmentsRaw[code];
        const mode = entry && typeof entry.mode === 'string' ? entry.mode.toLowerCase() : BUTTON_MODE_NONE;
        const value = entry && typeof entry.value === 'string' ? entry.value : '';
        nextAssignments[code] = { mode, value };
        applyButtonActionToControls(code, nextAssignments[code]);
      });
      buttonAssignments = nextAssignments;
      updateButtonMp3Options();
      return { definitions: buttonDefinitions, assignments: buttonAssignments };
    };

    async function saveButtonAction(code, mode, rawValue) {
      if (!code) {
        return;
      }
      let normalizedMode = typeof mode === 'string' ? mode.toLowerCase() : BUTTON_MODE_NONE;
      let normalizedValue = '';
      if (normalizedMode === BUTTON_MODE_MP3) {
        normalizedValue = typeof rawValue === 'string' ? rawValue.trim() : '';
        if (!normalizedValue) {
          normalizedMode = BUTTON_MODE_NONE;
        }
      } else if (normalizedMode === BUTTON_MODE_COMMAND) {
        normalizedValue = typeof rawValue === 'string' ? rawValue.trim() : '';
        if (!normalizedValue) {
          normalizedMode = BUTTON_MODE_NONE;
        }
      } else {
        normalizedMode = BUTTON_MODE_NONE;
      }
      const currentAssignment = buttonAssignments[code];
      const currentMode = currentAssignment ? currentAssignment.mode : BUTTON_MODE_NONE;
      const currentValue = currentAssignment ? (currentAssignment.value || '') : '';
      if (
        normalizedMode === currentMode
        && (
          normalizedMode === BUTTON_MODE_NONE
          || normalizedValue === currentValue
        )
      ) {
        return;
      }
      const entry = { mode: normalizedMode };
      if (normalizedMode !== BUTTON_MODE_NONE) {
        entry.value = normalizedValue;
      }
      const payload = { button_actions: { [code]: entry } };
      const currentDevice = audioSelect.value;
      if (currentDevice) {
        payload.audio_device = currentDevice;
      }
      try {
        setStatus('Speichere Tasten-Aktion …');
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        const selected = typeof data.audio_device === 'string' ? data.audio_device : null;
        syncAudioSelection(data.audio_outputs, selected);
        const volumeValue = syncVolume(data.audio_volume);
        syncMotorLimits(data.motor_limits);
        const soundInfo = syncSoundSettings(data.sound);
        const buttonInfo = syncButtonActions(data.button_actions);
        let success = false;
        if (buttonInfo && buttonInfo.assignments && buttonInfo.assignments[code]) {
          const saved = buttonInfo.assignments[code];
          if (normalizedMode === BUTTON_MODE_NONE) {
            success = !saved || saved.mode === BUTTON_MODE_NONE || !saved.mode;
          } else if (normalizedMode === BUTTON_MODE_MP3) {
            success = saved.mode === BUTTON_MODE_MP3
              && saved.value
              && saved.value.toLowerCase() === normalizedValue.toLowerCase();
          } else if (normalizedMode === BUTTON_MODE_COMMAND) {
            success = saved.mode === BUTTON_MODE_COMMAND && saved.value === normalizedValue;
          }
        }
        if (success) {
          const messages = [];
          if (selected) {
            if (volumeValue !== null) {
              messages.push('Audio-Ausgabe & Lautstärke synchronisiert');
            } else {
              messages.push('Audio-Ausgabe synchronisiert');
            }
          }
          if (soundInfo) {
            if (!soundInfo.configured) {
              messages.push('Kein MP3-Verzeichnis konfiguriert');
            } else if (Array.isArray(soundInfo.files) && soundInfo.files.length === 0) {
              messages.push('Keine MP3-Dateien gefunden');
            }
          }
          messages.push('Tasten-Aktion gespeichert');
          setStatus(`${messages.join(' · ')}.`, 'success');
        } else {
          setStatus('Tasten-Aktion konnte nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern der Tasten-Aktion fehlgeschlagen', err);
        setStatus('Tasten-Aktion konnte nicht gespeichert werden.', 'error');
      }
    }

    const setStatus = (message, tone = '') => {
      statusEl.textContent = message ?? '';
      statusEl.classList.remove('success', 'error');
      if (tone === 'success') {
        statusEl.classList.add('success');
      } else if (tone === 'error') {
        statusEl.classList.add('error');
      }
    };

    const formatMotorPercent = (value) => `${Math.round((Number.parseFloat(value) || 0) * 100)}%`;

    const clampMotorLimit = (value) => {
      if (!motorConfig) {
        return null;
      }
      const { min, max, step } = motorConfig;
      const numeric = Number.parseFloat(value);
      if (!Number.isFinite(numeric)) {
        return null;
      }
      const limited = Math.max(min, Math.min(max, numeric));
      const steps = Math.round((limited - min) / step);
      const quantized = min + steps * step;
      const clamped = Math.max(min, Math.min(max, quantized));
      return Number.parseFloat(clamped.toFixed(4));
    };

    const clampMotorFromSlider = (value) => {
      if (!motorConfig) {
        return null;
      }
      const numeric = Number.parseFloat(value);
      if (!Number.isFinite(numeric)) {
        return null;
      }
      return clampMotorLimit(numeric / 100);
    };

    const parseSoundboardPort = (value) => {
      if (typeof value === 'number') {
        if (Number.isInteger(value) && value >= 1 && value <= 65535) {
          return value;
        }
        return null;
      }
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) {
          return null;
        }
        const parsed = Number.parseInt(trimmed, 10);
        if (Number.isInteger(parsed) && parsed >= 1 && parsed <= 65535) {
          return parsed;
        }
      }
      return null;
    };

    const parseCameraTarget = (value) => {
      if (typeof value === 'number') {
        if (Number.isInteger(value) && value >= 1 && value <= 65535) {
          return { port: value, path: '', raw: String(value) };
        }
        return null;
      }
      if (typeof value !== 'string') {
        return null;
      }
      const trimmed = value.trim();
      if (!trimmed) {
        return null;
      }
      const slashIndex = trimmed.indexOf('/');
      const portPart = slashIndex === -1 ? trimmed : trimmed.slice(0, slashIndex);
      const pathPart = slashIndex === -1 ? '' : trimmed.slice(slashIndex + 1);
      const numeric = Number.parseInt(portPart, 10);
      if (!Number.isInteger(numeric) || numeric < 1 || numeric > 65535) {
        return null;
      }
      let normalizedPath = '';
      if (pathPart) {
        const segments = pathPart
          .split('/')
          .map((segment) => segment.trim())
          .filter(Boolean);
        if (segments.length > 0) {
          normalizedPath = `/${segments.join('/')}`;
          if (pathPart.trim().endsWith('/') && !normalizedPath.endsWith('/')) {
            normalizedPath += '/';
          }
        }
      }
      return { port: numeric, path: normalizedPath, raw: `${numeric}${normalizedPath}` };
    };

    const parseLightUrl = (value) => {
      if (typeof value !== 'string') {
        return null;
      }
      const trimmed = value.trim();
      if (!trimmed) {
        return null;
      }
      try {
        const parsed = new URL(trimmed);
        if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {
          return null;
        }
      } catch (err) {
        return null;
      }
      return trimmed;
    };

    const syncMotorLimits = (info) => {
      if (!motorForward || !motorReverse || !motorForwardValue || !motorReverseValue) {
        return null;
      }
      if (!info || !Number.isFinite(info.forward) || !Number.isFinite(info.reverse)) {
        motorConfig = null;
        motorForward.disabled = true;
        motorReverse.disabled = true;
        motorForwardValue.textContent = '–';
        motorReverseValue.textContent = '–';
        return null;
      }
      const min = Number.isFinite(info.min) ? info.min : 0;
      const max = Number.isFinite(info.max) ? info.max : 1;
      const step = Number.isFinite(info.step) && info.step > 0 ? info.step : 0.01;
      motorConfig = { min, max, step };
      const sliderMin = Math.round(min * 100);
      const sliderMax = Math.round(max * 100);
      const sliderStep = Math.max(1, Math.round(step * 100));
      motorForward.min = String(sliderMin);
      motorForward.max = String(sliderMax);
      motorForward.step = String(sliderStep);
      motorReverse.min = String(sliderMin);
      motorReverse.max = String(sliderMax);
      motorReverse.step = String(sliderStep);
      const forwardValue = clampMotorLimit(info.forward);
      const reverseValue = clampMotorLimit(info.reverse);
      if (forwardValue === null || reverseValue === null) {
        motorConfig = null;
        motorForward.disabled = true;
        motorReverse.disabled = true;
        motorForwardValue.textContent = '–';
        motorReverseValue.textContent = '–';
        return null;
      }
      motorForward.disabled = false;
      motorReverse.disabled = false;
      motorForward.value = String(Math.round(forwardValue * 100));
      motorReverse.value = String(Math.round(reverseValue * 100));
      motorForwardValue.textContent = formatMotorPercent(forwardValue);
      motorReverseValue.textContent = formatMotorPercent(reverseValue);
      return { forward: forwardValue, reverse: reverseValue };
    };

    const getCurrentMotorValues = () => {
      if (!motorConfig || !motorForward || !motorReverse) {
        return null;
      }
      const forward = clampMotorFromSlider(motorForward.value);
      const reverse = clampMotorFromSlider(motorReverse.value);
      if (forward === null || reverse === null) {
        return null;
      }
      return { forward, reverse };
    };

    const syncAudioSelection = (options, selectedId) => {
      const normalized = Array.isArray(options)
        ? options
            .map((opt) => ({ id: opt?.id ?? '', label: opt?.label ?? String(opt?.id ?? '') }))
            .filter((opt) => String(opt.id).length > 0)
        : [];
      const signature = JSON.stringify(normalized);
      if (signature !== audioOptionsSignature) {
        audioOptionsSignature = signature;
        audioSelect.innerHTML = '';
        if (normalized.length === 0) {
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'Keine passenden Audio-Ausgänge gefunden';
          option.disabled = true;
          option.selected = true;
          audioSelect.append(option);
        } else {
          normalized.forEach((opt) => {
            const option = document.createElement('option');
            option.value = String(opt.id);
            option.textContent = opt.label;
            audioSelect.append(option);
          });
        }
      }
      const desired = String(selectedId ?? '');
      const hasDesired = normalized.some((opt) => String(opt.id) === desired);
      const fallback = normalized.length > 0 ? String(normalized[0].id) : '';
      const targetValue = hasDesired ? desired : fallback;
      if (audioSelect.value !== targetValue) {
        audioSelect.value = targetValue;
      }
      audioSelect.disabled = normalized.length === 0;
      return targetValue || null;
    };

    const formatVolume = (value) => `${Math.round(Number.parseFloat(value) || 0)}%`;

    const clampVolume = (raw) => {
      if (!volumeConfig) {
        return null;
      }
      const { min, max, step } = volumeConfig;
      const numeric = Number.parseFloat(raw);
      if (!Number.isFinite(numeric)) {
        return null;
      }
      const limited = Math.max(min, Math.min(max, numeric));
      const steps = Math.round((limited - min) / step);
      return min + steps * step;
    };

    const syncVolume = (info) => {
      if (!volumeSlider || !volumeValue || !volumeContainer) {
        return null;
      }
      if (!info || !Number.isFinite(info.value)) {
        volumeConfig = null;
        volumeContainer.hidden = true;
        volumeSlider.disabled = true;
        volumeValue.textContent = '–';
        return null;
      }
      const min = Number.isFinite(info.min) ? info.min : 0;
      const max = Number.isFinite(info.max) ? info.max : 100;
      const step = Number.isFinite(info.step) && info.step > 0 ? info.step : 1;
      volumeConfig = { min, max, step };
      volumeSlider.min = String(min);
      volumeSlider.max = String(max);
      volumeSlider.step = String(step);
      const value = clampVolume(info.value);
      if (value === null) {
        volumeConfig = null;
        volumeContainer.hidden = true;
        volumeSlider.disabled = true;
        volumeValue.textContent = '–';
        return null;
      }
      volumeSlider.value = String(value);
      volumeSlider.disabled = false;
      volumeContainer.hidden = false;
      volumeValue.textContent = formatVolume(value);
      return value;
    };

    const getSelectLabel = (select) => {
      if (!select) {
        return '';
      }
      const option = select.options[select.selectedIndex];
      return option ? option.textContent.trim() : select.value;
    };

    const playSoundPreview = (select, button) => {
      if (!select || !button || !soundPreviewPlayer) {
        return;
      }
      if (select.disabled) {
        updatePreviewButtonState();
        return;
      }
      const value = select.value;
      if (!value) {
        setStatus('Bitte zuerst einen Sound auswählen.', 'error');
        updatePreviewButtonState();
        return;
      }
      const label = getSelectLabel(select);
      const url = `/api/sound-preview?file=${encodeURIComponent(value)}&v=${Date.now()}`;
      button.disabled = true;
      try {
        soundPreviewPlayer.pause();
        soundPreviewPlayer.currentTime = 0;
      } catch (err) {
        console.error('Zurücksetzen der Sound-Vorschau fehlgeschlagen', err);
      }
      soundPreviewPlayer.src = url;
      let playback;
      try {
        playback = soundPreviewPlayer.play();
      } catch (err) {
        console.error('Sound-Vorschau konnte nicht gestartet werden', err);
        setStatus('Sound konnte nicht abgespielt werden.', 'error');
        button.disabled = false;
        return;
      }
      const onSuccess = () => {
        setStatus(`Spiele „${label}“ …`, 'success');
      };
      const onError = (err) => {
        console.error('Sound-Vorschau fehlgeschlagen', err);
        setStatus('Sound konnte nicht abgespielt werden.', 'error');
      };
      if (playback && typeof playback.then === 'function') {
        playback.then(onSuccess).catch(onError).finally(() => {
          button.disabled = false;
        });
      } else {
        onSuccess();
        button.disabled = false;
      }
    };

    const syncSoundSettings = (info) => {
      if (!soundDirectoryInput || !soundDirectorySave || !connectedSoundSelect || !startupSoundSelect) {
        return null;
      }
      const setSelectPlaceholder = (select, message) => {
        if (!select) {
          return;
        }
        select.innerHTML = '';
        const option = document.createElement('option');
        option.value = '';
        option.textContent = message;
        select.append(option);
        select.disabled = true;
        select.value = '';
      };
      const populateSoundSelect = (select, files, selectedValue) => {
        if (!select) {
          return '';
        }
        select.innerHTML = '';
        const noneOption = document.createElement('option');
        noneOption.value = '';
        noneOption.textContent = 'Kein Sound';
        select.append(noneOption);
        files.forEach((file) => {
          const option = document.createElement('option');
          option.value = file;
          option.textContent = file;
          select.append(option);
        });
        const normalized = selectedValue
          ? files.find((file) => file.toLowerCase() === selectedValue.toLowerCase())
          : null;
        const finalValue = normalized || '';
        select.value = finalValue;
        select.disabled = false;
        return finalValue;
      };

      connectedSoundSelect.innerHTML = '';
      startupSoundSelect.innerHTML = '';

      if (!info || typeof info !== 'object') {
        soundDirectoryInput.value = '';
        soundDirectoryInput.disabled = true;
        soundDirectorySave.disabled = true;
        soundDirectoryConfigured = false;
        updateSoundUploadAvailability();
        if (webPortInput) {
          webPortInput.value = '';
          webPortInput.disabled = true;
        }
        if (webPortSave) {
          webPortSave.disabled = true;
        }
        if (soundboardPortInput) {
          soundboardPortInput.value = '';
          soundboardPortInput.disabled = true;
        }
        if (soundboardPortSave) {
          soundboardPortSave.disabled = true;
        }
        if (cameraPortInput) {
          cameraPortInput.value = '';
          cameraPortInput.disabled = true;
        }
        if (cameraPortSave) {
          cameraPortSave.disabled = true;
        }
        if (lightLinkInput) {
          lightLinkInput.value = '';
          lightLinkInput.disabled = true;
        }
        if (lightLinkSave) {
          lightLinkSave.disabled = true;
        }
        const message = 'Kein MP3-Verzeichnis konfiguriert';
        setSelectPlaceholder(connectedSoundSelect, message);
        setSelectPlaceholder(startupSoundSelect, message);
        currentSoundFiles = [];
        updateButtonMp3Options();
        updatePreviewButtonState();
        return null;
      }

      const directory = typeof info.directory === 'string' ? info.directory : '';
      const files = Array.isArray(info.files)
        ? info.files.filter((value) => typeof value === 'string')
        : [];
      const connectedSound = typeof info.connected_sound === 'string' ? info.connected_sound : '';
      const startupSound = typeof info.startup_sound === 'string' ? info.startup_sound : '';
      const webPort = parseSoundboardPort(info.web_port);
      const soundboardPort = parseSoundboardPort(info.soundboard_port);
      const cameraTarget = parseCameraTarget(info.camera_port);
      const lightUrl = parseLightUrl(info.light_url);
      soundDirectoryConfigured = Boolean(directory);
      updateSoundUploadAvailability();
      soundDirectoryInput.disabled = false;
      soundDirectoryInput.value = directory;
      soundDirectorySave.disabled = false;
      if (webPortInput) {
        webPortInput.disabled = false;
        webPortInput.value = webPort !== null ? String(webPort) : '';
      }
      if (webPortSave) {
        webPortSave.disabled = false;
      }
      if (soundboardPortInput) {
        soundboardPortInput.disabled = false;
        soundboardPortInput.value = soundboardPort !== null ? String(soundboardPort) : '';
      }
      if (soundboardPortSave) {
        soundboardPortSave.disabled = false;
      }
      if (cameraPortInput) {
        cameraPortInput.disabled = false;
        cameraPortInput.value = cameraTarget ? cameraTarget.raw : '';
      }
      if (cameraPortSave) {
        cameraPortSave.disabled = false;
      }
      if (lightLinkInput) {
        lightLinkInput.disabled = false;
        lightLinkInput.value = lightUrl || '';
      }
      if (lightLinkSave) {
        lightLinkSave.disabled = false;
      }

      let connectedSelected = '';
      let startupSelected = '';
      if (files.length === 0) {
        const message = soundDirectoryConfigured
          ? 'Keine MP3-Dateien gefunden'
          : 'Kein MP3-Verzeichnis konfiguriert';
        setSelectPlaceholder(connectedSoundSelect, message);
        setSelectPlaceholder(startupSoundSelect, message);
        currentSoundFiles = [];
      } else {
        connectedSelected = populateSoundSelect(connectedSoundSelect, files, connectedSound);
        startupSelected = populateSoundSelect(startupSoundSelect, files, startupSound);
        currentSoundFiles = files.slice();
      }

      updateButtonMp3Options();
      updatePreviewButtonState();
      return {
        directory,
        files,
        connectedSound: connectedSelected || '',
        startupSound: startupSelected || '',
        webPort,
        soundboardPort,
        cameraTarget,
        lightUrl: lightUrl || '',
        configured: soundDirectoryConfigured,
      };
    };

    const syncGamepadSettings = (info) => {
      if (!disconnectCommandInput || !disconnectCommandSave) {
        return null;
      }
      if (!info || typeof info !== 'object') {
        disconnectCommandInput.value = '';
        disconnectCommandInput.disabled = true;
        disconnectCommandSave.disabled = true;
        return null;
      }
      const command = typeof info.disconnect_command === 'string' ? info.disconnect_command : '';
      disconnectCommandInput.disabled = false;
      disconnectCommandInput.value = command;
      disconnectCommandSave.disabled = false;
      return { disconnectCommand: command };
    };

    async function loadState() {
      try {
        setStatus('Lade aktuelle Einstellungen …');
        const resp = await fetch('/api/state');
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        const selected = typeof data.audio_device === 'string' ? data.audio_device : null;
        const current = syncAudioSelection(data.audio_outputs, selected);
        const volumeValue = syncVolume(data.audio_volume);
        const motorValues = syncMotorLimits(data.motor_limits);
        const soundInfo = syncSoundSettings(data.sound);
        const gamepadInfo = syncGamepadSettings(data.gamepad);
        const buttonInfo = syncButtonActions(data.button_actions);
        const messageParts = [];
        let tone = '';
        if (current) {
          if (volumeValue !== null) {
            messageParts.push('Audio-Ausgabe und Lautstärke geladen');
          } else {
            messageParts.push('Audio-Ausgabe geladen (keine Lautstärke-Steuerung verfügbar)');
          }
          tone = 'success';
        } else {
          messageParts.push('Keine Audio-Ausgabegeräte verfügbar');
          tone = 'error';
        }
        if (motorValues) {
          messageParts.push('Motor-Limits geladen');
          if (!tone) {
            tone = 'success';
          }
        }
        if (soundInfo) {
          if (!soundInfo.configured) {
            messageParts.push('MP3-Verzeichnis nicht konfiguriert');
          } else if (soundInfo.files.length > 0) {
            messageParts.push('Sound-Einstellungen geladen');
          } else {
            messageParts.push('MP3-Verzeichnis geladen (keine Dateien gefunden)');
          }
          if (!tone) {
            tone = 'success';
          }
        }
        if (gamepadInfo) {
          messageParts.push(gamepadInfo.disconnectCommand ? 'Gamepad-Befehl geladen' : 'Gamepad-Befehl entfernt');
          if (!tone) {
            tone = 'success';
          }
        }
        if (buttonInfo) {
          messageParts.push('Tasten-Aktionen geladen');
          if (!tone) {
            tone = 'success';
          }
        }
        const message = messageParts.length > 0 ? `${messageParts.join(' · ')}.` : '';
        setStatus(message, tone);
      } catch (err) {
        console.error('Laden fehlgeschlagen', err);
        setStatus('Konnte Einstellungen nicht laden.', 'error');
        audioSelect.disabled = true;
        syncMotorLimits(null);
        syncSoundSettings(null);
        syncButtonActions(null);
        syncGamepadSettings(null);
      }
    }

    async function saveSelection(deviceId) {
      if (!deviceId) {
        return;
      }
      try {
        setStatus('Speichere …');
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ audio_device: deviceId })
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncAudioSelection(data.audio_outputs, data.audio_device);
        const volumeValue = syncVolume(data.audio_volume);
        syncMotorLimits(data.motor_limits);
        syncSoundSettings(data.sound);
        syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        if (volumeValue !== null) {
          setStatus('Audio-Ausgabe und Lautstärke gespeichert.', 'success');
        } else {
          setStatus('Audio-Ausgabe gespeichert.', 'success');
        }
      } catch (err) {
        console.error('Speichern fehlgeschlagen', err);
        setStatus('Speichern fehlgeschlagen.', 'error');
      }
    }

    async function saveVolume(rawValue) {
      if (!volumeConfig) {
        return;
      }
      const value = clampVolume(rawValue);
      if (value === null) {
        return;
      }
      try {
        setStatus('Speichere Lautstärke …');
        const payload = { audio_volume: value };
        const currentDevice = audioSelect.value;
        if (currentDevice) {
          payload.audio_device = currentDevice;
        }
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncAudioSelection(data.audio_outputs, data.audio_device);
        syncMotorLimits(data.motor_limits);
        const updated = syncVolume(data.audio_volume);
        syncSoundSettings(data.sound);
        syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        if (updated !== null) {
          setStatus('Lautstärke gespeichert.', 'success');
        } else {
          setStatus('Keine Lautstärke-Steuerung verfügbar.', 'error');
        }
      } catch (err) {
        console.error('Speichern der Lautstärke fehlgeschlagen', err);
        setStatus('Speichern der Lautstärke fehlgeschlagen.', 'error');
      }
    }

    async function saveSoundDirectory(rawPath) {
      if (!soundDirectoryInput || !soundDirectorySave) {
        return;
      }
      const value = typeof rawPath === 'string' ? rawPath.trim() : '';
      const removingDirectory = value === '';
      try {
        setStatus(removingDirectory ? 'Entferne MP3-Verzeichnis …' : 'Speichere Sound-Pfad …');
        const payload = { sound_directory: value };
        const currentDevice = audioSelect.value;
        if (currentDevice) {
          payload.audio_device = currentDevice;
        }
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncAudioSelection(data.audio_outputs, data.audio_device);
        syncVolume(data.audio_volume);
        syncMotorLimits(data.motor_limits);
        const soundInfo = syncSoundSettings(data.sound);
        syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        const configured = !!soundInfo && soundInfo.configured;
        const hasFiles = configured && Array.isArray(soundInfo.files) && soundInfo.files.length > 0;
        if (!configured) {
          setStatus('MP3-Verzeichnis entfernt.', 'success');
        } else if (hasFiles) {
          setStatus('MP3-Verzeichnis gespeichert.', 'success');
        } else {
          setStatus('MP3-Verzeichnis gespeichert (keine MP3-Dateien gefunden).', 'success');
        }
      } catch (err) {
        console.error('Speichern des Sound-Pfads fehlgeschlagen', err);
        setStatus('Sound-Pfad konnte nicht gespeichert werden.', 'error');
      }
    }

    async function handleSoundUpload() {
      if (!soundUploadInput || !soundUploadButton) {
        return;
      }
      if (soundUploadInProgress) {
        return;
      }
      if (!soundDirectoryConfigured) {
        setStatus('Kein MP3-Verzeichnis konfiguriert.', 'error');
        updateSoundUploadAvailability();
        return;
      }
      const file = soundUploadInput.files && soundUploadInput.files.length > 0
        ? soundUploadInput.files[0]
        : null;
      if (!file) {
        setStatus('Bitte eine MP3-Datei auswählen.', 'error');
        updateSoundUploadAvailability();
        return;
      }
      const fileName = typeof file.name === 'string' ? file.name : '';
      if (!fileName.toLowerCase().endsWith('.mp3')) {
        setStatus('Bitte eine MP3-Datei auswählen.', 'error');
        soundUploadInput.value = '';
        updateSoundUploadAvailability();
        return;
      }
      if (file.size > SOUND_UPLOAD_MAX_BYTES) {
        setStatus('MP3-Datei ist zu groß (max. 20 MB).', 'error');
        soundUploadInput.value = '';
        updateSoundUploadAvailability();
        return;
      }
      const formData = new FormData();
      formData.append('file', file, fileName || 'sound.mp3');
      const displayName = fileName || 'MP3';
      let clearSelection = false;
      soundUploadInProgress = true;
      updateSoundUploadAvailability();
      try {
        setStatus(`Lade „${displayName}“ hoch …`);
        const resp = await fetch('/api/sounds/upload', {
          method: 'POST',
          body: formData,
        });
        let data = null;
        try {
          data = await resp.json();
        } catch (err) {
          data = null;
        }
        if (!resp.ok) {
          const message = data && typeof data.message === 'string'
            ? data.message
            : `MP3 konnte nicht hochgeladen werden (Status ${resp.status}).`;
          setStatus(message, 'error');
          return;
        }
        if (!data || typeof data !== 'object') {
          setStatus('Antwort vom Server konnte nicht verarbeitet werden.', 'error');
          return;
        }
        const selected = typeof data.audio_device === 'string' ? data.audio_device : null;
        syncAudioSelection(data.audio_outputs, selected);
        const volumeValue = syncVolume(data.audio_volume);
        syncMotorLimits(data.motor_limits);
        const soundInfo = syncSoundSettings(data.sound);
        syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        const uploadedName = typeof data.uploaded_file === 'string' ? data.uploaded_file : fileName;
        const successMessage = typeof data.upload_message === 'string'
          ? data.upload_message
          : `MP3 „${uploadedName || displayName}“ hochgeladen.`;
        const normalizedSuccessMessage = successMessage.endsWith('.')
          ? successMessage.slice(0, -1)
          : successMessage;
        const messages = [];
        if (selected) {
          messages.push(volumeValue !== null ? 'Audio-Ausgabe & Lautstärke synchronisiert' : 'Audio-Ausgabe synchronisiert');
        }
        if (soundInfo) {
          if (!soundInfo.configured) {
            messages.push('Kein MP3-Verzeichnis konfiguriert');
          } else if (Array.isArray(soundInfo.files) && soundInfo.files.length === 0) {
            messages.push('Keine MP3-Dateien gefunden');
          }
        }
        messages.push(normalizedSuccessMessage);
        setStatus(`${messages.join(' · ')}.`, 'success');
        clearSelection = true;
      } catch (err) {
        console.error('Upload der MP3-Datei fehlgeschlagen', err);
        setStatus('MP3-Datei konnte nicht hochgeladen werden.', 'error');
      } finally {
        soundUploadInProgress = false;
        if (clearSelection) {
          soundUploadInput.value = '';
        }
        updateSoundUploadAvailability();
      }
    }

    async function saveWebPort(rawPort) {
      if (!webPortInput || !webPortSave) {
        return;
      }
      const rawValue = typeof rawPort === 'string' ? rawPort.trim() : String(rawPort ?? '').trim();
      if (!rawValue) {
        setStatus('Bitte einen gültigen Port eingeben.', 'error');
        webPortInput.focus();
        return;
      }
      const numeric = Number.parseInt(rawValue, 10);
      if (!Number.isInteger(numeric) || numeric < 1 || numeric > 65535) {
        setStatus('Port muss zwischen 1 und 65535 liegen.', 'error');
        webPortInput.focus();
        return;
      }
      try {
        setStatus('Speichere Webserver-Port …');
        const payload = { web_port: numeric };
        const currentDevice = audioSelect.value;
        if (currentDevice) {
          payload.audio_device = currentDevice;
        }
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncAudioSelection(data.audio_outputs, data.audio_device);
        syncVolume(data.audio_volume);
        syncMotorLimits(data.motor_limits);
        const soundInfo = syncSoundSettings(data.sound);
        syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        const savedPort = soundInfo ? soundInfo.webPort : null;
        if (savedPort === numeric) {
          setStatus('Webserver-Port gespeichert. Bitte Anwendung neu starten.', 'success');
        } else {
          setStatus('Webserver-Port konnte nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern des Webserver-Ports fehlgeschlagen', err);
        setStatus('Webserver-Port konnte nicht gespeichert werden.', 'error');
      }
    }

    async function saveSoundboardPort(rawPort) {
      if (!soundboardPortInput || !soundboardPortSave) {
        return;
      }
      const rawValue = typeof rawPort === 'string' ? rawPort.trim() : String(rawPort ?? '').trim();
      if (!rawValue) {
        setStatus('Bitte einen gültigen Port eingeben.', 'error');
        soundboardPortInput.focus();
        return;
      }
      const numeric = Number.parseInt(rawValue, 10);
      if (!Number.isInteger(numeric) || numeric < 1 || numeric > 65535) {
        setStatus('Port muss zwischen 1 und 65535 liegen.', 'error');
        soundboardPortInput.focus();
        return;
      }
      try {
        setStatus('Speichere Soundboard-Port …');
        const payload = { soundboard_port: numeric };
        const currentDevice = audioSelect.value;
        if (currentDevice) {
          payload.audio_device = currentDevice;
        }
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncAudioSelection(data.audio_outputs, data.audio_device);
        syncVolume(data.audio_volume);
        syncMotorLimits(data.motor_limits);
        const soundInfo = syncSoundSettings(data.sound);
        syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        const savedPort = soundInfo ? soundInfo.soundboardPort : null;
        if (savedPort === numeric) {
          setStatus('Soundboard-Port gespeichert.', 'success');
        } else {
          setStatus('Soundboard-Port konnte nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern des Soundboard-Ports fehlgeschlagen', err);
        setStatus('Soundboard-Port konnte nicht gespeichert werden.', 'error');
      }
    }

    async function saveCameraPort(rawPort) {
      if (!cameraPortInput || !cameraPortSave) {
        return;
      }
      const rawValue = typeof rawPort === 'string' ? rawPort.trim() : String(rawPort ?? '').trim();
      if (!rawValue) {
        setStatus('Bitte eine gültige Kamera-Adresse eingeben.', 'error');
        cameraPortInput.focus();
        return;
      }
      const parsed = parseCameraTarget(rawValue);
      if (!parsed) {
        setStatus('Port muss zwischen 1 und 65535 liegen. Optionaler Pfad beginnt mit "/".', 'error');
        cameraPortInput.focus();
        return;
      }
      try {
        setStatus('Speichere Kamera-Adresse …');
        const payload = { camera_port: parsed.raw };
        const currentDevice = audioSelect.value;
        if (currentDevice) {
          payload.audio_device = currentDevice;
        }
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncAudioSelection(data.audio_outputs, data.audio_device);
        syncVolume(data.audio_volume);
        syncMotorLimits(data.motor_limits);
        const soundInfo = syncSoundSettings(data.sound);
        syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        const savedTarget = soundInfo && soundInfo.cameraTarget ? soundInfo.cameraTarget.raw : null;
        if (savedTarget === parsed.raw) {
          setStatus('Kamera-Adresse gespeichert.', 'success');
        } else {
          setStatus('Kamera-Adresse konnte nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern der Kamera-Adresse fehlgeschlagen', err);
        setStatus('Kamera-Adresse konnte nicht gespeichert werden.', 'error');
      }
    }

    async function saveLightLink(rawUrl) {
      if (!lightLinkInput || !lightLinkSave) {
        return;
      }
      const rawValue = typeof rawUrl === 'string' ? rawUrl.trim() : String(rawUrl ?? '').trim();
      if (!rawValue) {
        setStatus('Bitte eine gültige URL eingeben.', 'error');
        lightLinkInput.focus();
        return;
      }
      if (/\s/.test(rawValue)) {
        setStatus('URL darf keine Leerzeichen enthalten.', 'error');
        lightLinkInput.focus();
        return;
      }
      let normalized = rawValue;
      if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*:\/\//.test(normalized)) {
        normalized = `http://${normalized}`;
      }
      let parsed;
      try {
        parsed = new URL(normalized);
      } catch (err) {
        setStatus('URL ist ungültig.', 'error');
        lightLinkInput.focus();
        return;
      }
      if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {
        setStatus('URL muss mit http:// oder https:// beginnen.', 'error');
        lightLinkInput.focus();
        return;
      }
      const colonIndex = normalized.indexOf(':');
      const finalUrl =
        colonIndex === -1
          ? normalized
          : `${parsed.protocol.slice(0, -1)}:${normalized.slice(colonIndex + 1)}`;
      try {
        setStatus('Speichere Weblink …');
        const payload = { light_url: finalUrl };
        const currentDevice = audioSelect.value;
        if (currentDevice) {
          payload.audio_device = currentDevice;
        }
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncAudioSelection(data.audio_outputs, data.audio_device);
        syncVolume(data.audio_volume);
        syncMotorLimits(data.motor_limits);
        const soundInfo = syncSoundSettings(data.sound);
        syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        const savedUrl = soundInfo ? parseLightUrl(soundInfo.lightUrl) : null;
        if (savedUrl === finalUrl) {
          setStatus('Weblink gespeichert.', 'success');
        } else {
          setStatus('Weblink konnte nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern des Weblinks fehlgeschlagen', err);
        setStatus('Weblink konnte nicht gespeichert werden.', 'error');
      }
    }

    async function saveDisconnectCommand(rawCommand) {
      if (!disconnectCommandInput || !disconnectCommandSave) {
        return;
      }
      const value = typeof rawCommand === 'string' ? rawCommand.trim() : '';
      try {
        setStatus('Speichere Gamepad-Befehl …');
        const payload = { disconnect_command: value };
        const currentDevice = audioSelect.value;
        if (currentDevice) {
          payload.audio_device = currentDevice;
        }
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncAudioSelection(data.audio_outputs, data.audio_device);
        syncVolume(data.audio_volume);
        syncMotorLimits(data.motor_limits);
        syncSoundSettings(data.sound);
        const gamepadInfo = syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        const saved = gamepadInfo ? gamepadInfo.disconnectCommand : '';
        const success = value ? saved === value : saved === '';
        setStatus(
          success ? 'Gamepad-Befehl gespeichert.' : 'Gamepad-Befehl konnte nicht gespeichert werden.',
          success ? 'success' : 'error'
        );
      } catch (err) {
        console.error('Speichern des Gamepad-Befehls fehlgeschlagen', err);
        setStatus('Gamepad-Befehl konnte nicht gespeichert werden.', 'error');
      }
    }

    async function saveConnectedSound(fileName) {
      if (!connectedSoundSelect) {
        return;
      }
      const value = typeof fileName === 'string' ? fileName.trim() : '';
      try {
        setStatus('Speichere Connected Sound …');
        const payload = { connected_sound: value };
        const currentDevice = audioSelect.value;
        if (currentDevice) {
          payload.audio_device = currentDevice;
        }
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncAudioSelection(data.audio_outputs, data.audio_device);
        syncMotorLimits(data.motor_limits);
        syncVolume(data.audio_volume);
        const soundInfo = syncSoundSettings(data.sound);
        syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        const requested = value ? value.toLowerCase() : '';
        const saved = soundInfo && typeof soundInfo.connectedSound === 'string'
          ? soundInfo.connectedSound.toLowerCase()
          : '';
        const success = requested ? requested === saved : saved === '';
        setStatus(
          success ? 'Connected Sound gespeichert.' : 'Connected Sound konnte nicht gespeichert werden.',
          success ? 'success' : 'error'
        );
      } catch (err) {
        console.error('Speichern des Connected Sounds fehlgeschlagen', err);
        setStatus('Connected Sound konnte nicht gespeichert werden.', 'error');
      }
    }

    async function saveStartupSound(fileName) {
      if (!startupSoundSelect) {
        return;
      }
      const value = typeof fileName === 'string' ? fileName.trim() : '';
      try {
        setStatus('Speichere Start-Up-Sound …');
        const payload = { startup_sound: value };
        const currentDevice = audioSelect.value;
        if (currentDevice) {
          payload.audio_device = currentDevice;
        }
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncAudioSelection(data.audio_outputs, data.audio_device);
        syncMotorLimits(data.motor_limits);
        syncVolume(data.audio_volume);
        const soundInfo = syncSoundSettings(data.sound);
        syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        const requested = value ? value.toLowerCase() : '';
        const saved = soundInfo && typeof soundInfo.startupSound === 'string'
          ? soundInfo.startupSound.toLowerCase()
          : '';
        const success = requested ? requested === saved : saved === '';
        setStatus(
          success ? 'Start-Up-Sound gespeichert.' : 'Start-Up-Sound konnte nicht gespeichert werden.',
          success ? 'success' : 'error'
        );
      } catch (err) {
        console.error('Speichern des Start-Up-Sounds fehlgeschlagen', err);
        setStatus('Start-Up-Sound konnte nicht gespeichert werden.', 'error');
      }
    }

    async function saveMotorLimits(forward, reverse) {
      if (!motorForward || !motorReverse) {
        return;
      }
      try {
        setStatus('Speichere Motor-Grenzen …');
        const payload = { motor_limits: { forward, reverse } };
        const currentDevice = audioSelect.value;
        if (currentDevice) {
          payload.audio_device = currentDevice;
        }
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncAudioSelection(data.audio_outputs, data.audio_device);
        syncMotorLimits(data.motor_limits);
        syncVolume(data.audio_volume);
        syncSoundSettings(data.sound);
        syncGamepadSettings(data.gamepad);
        syncButtonActions(data.button_actions);
        setStatus('Motor-Grenzen gespeichert.', 'success');
      } catch (err) {
        console.error('Speichern der Motor-Grenzen fehlgeschlagen', err);
        setStatus('Motor-Grenzen konnten nicht gespeichert werden.', 'error');
      }
    }

    audioSelect.addEventListener('change', () => {
      const value = audioSelect.value;
      if (value) {
        saveSelection(value);
      }
    });

    if (motorForward && motorForwardValue) {
      motorForward.addEventListener('input', () => {
        const value = clampMotorFromSlider(motorForward.value);
        motorForwardValue.textContent = value === null ? '–' : formatMotorPercent(value);
      });
      motorForward.addEventListener('change', () => {
        const values = getCurrentMotorValues();
        if (!values) {
          return;
        }
        motorForward.value = String(Math.round(values.forward * 100));
        motorForwardValue.textContent = formatMotorPercent(values.forward);
        motorReverse.value = String(Math.round(values.reverse * 100));
        motorReverseValue.textContent = formatMotorPercent(values.reverse);
        saveMotorLimits(values.forward, values.reverse);
      });
    }

    if (motorReverse && motorReverseValue) {
      motorReverse.addEventListener('input', () => {
        const value = clampMotorFromSlider(motorReverse.value);
        motorReverseValue.textContent = value === null ? '–' : formatMotorPercent(value);
      });
      motorReverse.addEventListener('change', () => {
        const values = getCurrentMotorValues();
        if (!values) {
          return;
        }
        motorForward.value = String(Math.round(values.forward * 100));
        motorForwardValue.textContent = formatMotorPercent(values.forward);
        motorReverse.value = String(Math.round(values.reverse * 100));
        motorReverseValue.textContent = formatMotorPercent(values.reverse);
        saveMotorLimits(values.forward, values.reverse);
      });
    }

    if (volumeSlider) {
      volumeSlider.addEventListener('input', () => {
        volumeValue.textContent = formatVolume(volumeSlider.value);
      });
      volumeSlider.addEventListener('change', () => {
        const value = clampVolume(volumeSlider.value);
        if (value !== null) {
          saveVolume(value);
        }
      });
    }

    if (soundDirectorySave && soundDirectoryInput) {
      soundDirectorySave.addEventListener('click', () => {
        saveSoundDirectory(soundDirectoryInput.value ?? '');
      });
    }
    if (soundDirectoryInput) {
      soundDirectoryInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          saveSoundDirectory(soundDirectoryInput.value ?? '');
        }
      });
    }
    if (soundUploadInput) {
      soundUploadInput.addEventListener('change', () => {
        if (soundUploadInput.files && soundUploadInput.files.length > 0) {
          const file = soundUploadInput.files[0];
          if (file) {
            const name = typeof file.name === 'string' ? file.name : '';
            if (name && !name.toLowerCase().endsWith('.mp3')) {
              setStatus('Bitte eine MP3-Datei auswählen.', 'error');
              soundUploadInput.value = '';
            } else if (file.size > SOUND_UPLOAD_MAX_BYTES) {
              setStatus('MP3-Datei ist zu groß (max. 20 MB).', 'error');
              soundUploadInput.value = '';
            }
          }
        }
        updateSoundUploadAvailability();
      });
    }
    if (soundUploadButton) {
      soundUploadButton.addEventListener('click', () => {
        handleSoundUpload();
      });
    }
    if (webPortSave && webPortInput) {
      webPortSave.addEventListener('click', () => {
        saveWebPort(webPortInput.value ?? '');
      });
    }
    if (webPortInput) {
      webPortInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          saveWebPort(webPortInput.value ?? '');
        }
      });
    }
    if (soundboardPortSave && soundboardPortInput) {
      soundboardPortSave.addEventListener('click', () => {
        saveSoundboardPort(soundboardPortInput.value ?? '');
      });
    }
    if (soundboardPortInput) {
      soundboardPortInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          saveSoundboardPort(soundboardPortInput.value ?? '');
        }
      });
    }
    if (cameraPortSave && cameraPortInput) {
      cameraPortSave.addEventListener('click', () => {
        saveCameraPort(cameraPortInput.value ?? '');
      });
    }
    if (cameraPortInput) {
      cameraPortInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          saveCameraPort(cameraPortInput.value ?? '');
        }
      });
    }
    if (lightLinkSave && lightLinkInput) {
      lightLinkSave.addEventListener('click', () => {
        saveLightLink(lightLinkInput.value ?? '');
      });
    }
    if (lightLinkInput) {
      lightLinkInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          saveLightLink(lightLinkInput.value ?? '');
        }
      });
    }
    if (disconnectCommandSave && disconnectCommandInput) {
      disconnectCommandSave.addEventListener('click', () => {
        saveDisconnectCommand(disconnectCommandInput.value ?? '');
      });
    }
    if (disconnectCommandInput) {
      disconnectCommandInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          saveDisconnectCommand(disconnectCommandInput.value ?? '');
        }
      });
    }
    if (connectedSoundSelect) {
      connectedSoundSelect.addEventListener('change', () => {
        updatePreviewButtonState();
        const value = connectedSoundSelect.value ?? '';
        saveConnectedSound(value);
      });
    }
    if (connectedSoundPreviewButton && connectedSoundSelect) {
      connectedSoundPreviewButton.addEventListener('click', () => {
        playSoundPreview(connectedSoundSelect, connectedSoundPreviewButton);
      });
    }
    if (startupSoundSelect) {
      startupSoundSelect.addEventListener('change', () => {
        updatePreviewButtonState();
        const value = startupSoundSelect.value ?? '';
        saveStartupSound(value);
      });
    }
    if (startupSoundPreviewButton && startupSoundSelect) {
      startupSoundPreviewButton.addEventListener('click', () => {
        playSoundPreview(startupSoundSelect, startupSoundPreviewButton);
      });
    }

    loadState();
  </script>
</body>
</html>
