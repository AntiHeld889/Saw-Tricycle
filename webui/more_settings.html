<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Weitere Einstellungen · Saw Tricycle</title>
  <style>
    :root {
      color-scheme: dark;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #0d0d0d;
      color: #f2f2f2;
      margin: 0;
      min-height: 100vh;
      min-height: 100dvh;
      padding: calc(1.4rem + var(--safe-top)) calc(1.4rem + var(--safe-right)) calc(1.4rem + var(--safe-bottom)) calc(1.4rem + var(--safe-left));
      display: flex;
      justify-content: center;
      align-items: center;
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }
    .settings-card {
      width: 100%;
      max-width: 520px;
      background: #151515;
      border-radius: 16px;
      padding: clamp(1.2rem, 4vw + 0.4rem, 1.8rem);
      box-shadow: 0 0 40px rgba(0,0,0,0.45);
      display: flex;
      flex-direction: column;
      gap: 1.4rem;
    }
    .settings-header {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .back-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 42px;
      height: 42px;
      border-radius: 12px;
      background: rgba(229,9,20,0.16);
      border: 1px solid rgba(229,9,20,0.3);
      color: #fff;
      text-decoration: none;
      transition: background 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
    }
    .back-button:hover {
      background: rgba(229,9,20,0.28);
      border-color: rgba(229,9,20,0.55);
    }
    .back-button:active {
      transform: translateY(1px);
    }
    .settings-header h1 {
      margin: 0;
      font-size: clamp(1.25rem, 3vw, 1.7rem);
      font-weight: 600;
    }
    .settings-section {
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }
    .settings-section .field {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }
    .settings-section h2 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }
    .settings-section p {
      margin: 0;
      line-height: 1.5;
      color: #d5d5d5;
      font-size: 0.95rem;
    }
    .settings-section ul {
      margin: 0;
      padding-left: 1.1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      color: #e6e6e6;
      font-size: 0.95rem;
    }
    .settings-section li {
      line-height: 1.45;
    }
    .settings-section p.hint {
      color: #bbb;
      font-size: 0.9rem;
    }
    .status-container {
      border-radius: 12px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 0.75rem 1rem;
      font-size: 0.95rem;
      color: #bbb;
    }
    .status-container + .settings-section {
      margin-top: -0.2rem;
    }
    .status {
      margin: 0;
      min-height: 1.2em;
    }
    .status.success { color: #63f58c; }
    .status.error { color: #ff7a7a; }
    .steering-grid {
      display: grid;
      gap: 0.75rem;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }
    .number-input {
      display: flex;
      align-items: center;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 0.35rem 0.6rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .number-input input {
      flex: 1 1 auto;
      background: transparent;
      border: none;
      color: inherit;
      font: inherit;
      min-width: 0;
      padding: 0;
      -moz-appearance: textfield;
    }
    .number-input input:focus {
      outline: none;
    }
    .number-input input::-webkit-outer-spin-button,
    .number-input input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    .number-input span {
      margin-left: 0.35rem;
      opacity: 0.7;
      font-size: 0.9rem;
    }
    select {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.12);
      color: #fff;
      border-radius: 12px;
      padding: 0.55rem 0.75rem;
      font: inherit;
      min-height: 42px;
    }
    select:focus {
      outline: none;
      border-color: rgba(229,9,20,0.55);
      box-shadow: 0 0 0 3px rgba(229,9,20,0.2);
    }
    .number-input:focus-within {
      border-color: rgba(229,9,20,0.55);
      box-shadow: 0 0 0 3px rgba(229,9,20,0.2);
    }
    .motor-limits {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
    }
    .gpio-grid {
      display: grid;
      gap: 0.75rem;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }
    .motor-gpio-list {
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }
    .motor-channel {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .motor-channel h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
    }
    .motor-channel-grid {
      display: grid;
      gap: 0.75rem;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 0.9rem;
    }
    input[type="range"] {
      width: 100%;
      accent-color: #e50914;
    }
    output {
      min-width: 3ch;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .settings-footer {
      display: flex;
      justify-content: flex-end;
    }
    .primary-link {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      border-radius: 12px;
      padding: 0.55rem 1.1rem;
      background: rgba(229,9,20,0.16);
      border: 1px solid rgba(229,9,20,0.4);
      color: #fff;
      font-size: 0.95rem;
      font-weight: 600;
      text-decoration: none;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    .primary-link:hover {
      background: rgba(229,9,20,0.28);
      border-color: rgba(229,9,20,0.55);
    }
    .primary-link:active {
      transform: translateY(1px);
    }
    @media (max-width: 640px) {
      body {
        padding: calc(1rem + var(--safe-top)) calc(1rem + var(--safe-right)) calc(1rem + var(--safe-bottom)) calc(1rem + var(--safe-left));
      }
      .settings-card {
        border-radius: 12px;
      }
    }
    @media (orientation: landscape) and (max-height: 520px) {
      body {
        padding: calc(0.7rem + var(--safe-top)) calc(0.75rem + var(--safe-right)) calc(0.7rem + var(--safe-bottom)) calc(0.75rem + var(--safe-left));
        align-items: stretch;
      }
      .settings-card {
        padding: 0.95rem;
        gap: 1rem;
        max-height: calc(100dvh - var(--safe-top) - var(--safe-bottom) - 1.2rem);
        overflow-y: auto;
        overscroll-behavior: contain;
      }
      .settings-section {
        padding: 1rem;
        gap: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <div class="settings-card">
    <div class="settings-header">
      <a class="back-button" href="/settings" aria-label="Zurück zu den Einstellungen" title="Zurück">⟵</a>
      <h1>Weitere Einstellungen</h1>
    </div>
    <div class="status-container" role="status" aria-live="polite">
      <p id="status" class="status"></p>
    </div>
    <section class="settings-section" id="steeringAngles">
      <h2>Lenkwinkel</h2>
      <p class="hint">Definiert Mittelstellung und maximale Ausschläge des Servos.</p>
      <div class="steering-grid">
        <div class="field">
          <label for="steeringLeft">Links (max.)</label>
          <div class="number-input">
            <input id="steeringLeft" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Maximaler Lenkwinkel nach links" autocomplete="off">
            <span>°</span>
          </div>
        </div>
        <div class="field">
          <label for="steeringMid">Mitte</label>
          <div class="number-input">
            <input id="steeringMid" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Neutralstellung des Lenkservos" autocomplete="off">
            <span>°</span>
          </div>
        </div>
        <div class="field">
          <label for="steeringRight">Rechts (max.)</label>
          <div class="number-input">
            <input id="steeringRight" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Maximaler Lenkwinkel nach rechts" autocomplete="off">
            <span>°</span>
          </div>
        </div>
      </div>
    </section>
    <section class="settings-section" id="steeringCalibration">
      <h2>Servo-Kalibrierung</h2>
      <p class="hint">Speichert die realen Pulsweiten (µs) für Linksanschlag, Mitte und Rechtsanschlag.</p>
      <p class="hint">Die Felder zeigen immer den Puls, den der Pi gerade ausgibt. Tippe einen Wert ein, beobachte die Servo-Position und passe ihn bei Bedarf schrittweise an.</p>
      <div class="steering-grid">
        <div class="field">
          <label for="steeringPulseLeft">Links (µs)</label>
          <div class="number-input">
            <input id="steeringPulseLeft" type="number" inputmode="decimal" min="400" max="2600" step="1" aria-label="Pulsweite für Linksanschlag" autocomplete="off">
            <span>µs</span>
          </div>
        </div>
        <div class="field">
          <label for="steeringPulseMid">Mitte (µs)</label>
          <div class="number-input">
            <input id="steeringPulseMid" type="number" inputmode="decimal" min="400" max="2600" step="1" aria-label="Pulsweite für Mittelstellung" autocomplete="off">
            <span>µs</span>
          </div>
        </div>
        <div class="field">
          <label for="steeringPulseRight">Rechts (µs)</label>
          <div class="number-input">
            <input id="steeringPulseRight" type="number" inputmode="decimal" min="400" max="2600" step="1" aria-label="Pulsweite für Rechtsanschlag" autocomplete="off">
            <span>µs</span>
          </div>
        </div>
      </div>
    </section>
    <section class="settings-section" id="headAngles">
      <h2>Kopfwinkel</h2>
      <p class="hint">Einstellbare Positionen für das Kopf-Servo (links, Mitte, rechts).</p>
      <div class="steering-grid">
        <div class="field">
          <label for="headLeft">Links (max.)</label>
          <div class="number-input">
            <input id="headLeft" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Maximaler Kopfwinkel nach links" autocomplete="off">
            <span>°</span>
          </div>
        </div>
        <div class="field">
          <label for="headMid">Mitte</label>
          <div class="number-input">
            <input id="headMid" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Neutralstellung des Kopfservos" autocomplete="off">
            <span>°</span>
          </div>
        </div>
        <div class="field">
          <label for="headRight">Rechts (max.)</label>
          <div class="number-input">
            <input id="headRight" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Maximaler Kopfwinkel nach rechts" autocomplete="off">
            <span>°</span>
          </div>
        </div>
      </div>
    </section>
    <section class="settings-section">
      <h2>Motorgrenzen</h2>
      <p class="hint">Begrenzt den maximalen PWM-Anteil für den DC-Motor (0–100&nbsp;%).</p>
      <div class="motor-limits">
        <label for="motorForward">Vorwärts</label>
        <div class="slider-row">
          <input id="motorForward" type="range" min="0" max="100" step="1" aria-label="Vorwärtslimit einstellen">
          <output id="motorForwardValue" for="motorForward">–</output>
        </div>
      </div>
      <div class="motor-limits">
        <label for="motorReverse">Rückwärts</label>
        <div class="slider-row">
          <input id="motorReverse" type="range" min="0" max="100" step="1" aria-label="Rückwärtslimit einstellen">
          <output id="motorReverseValue" for="motorReverse">–</output>
        </div>
      </div>
    </section>
    <section class="settings-section" id="gpioSettings">
      <h2>GPIO-Belegung</h2>
      <p class="hint">Definiert die GPIO-Pins für Lenkservo, Kopfservo und den MDD10A-Motortreiber.</p>
      <div class="gpio-grid">
        <div class="field">
          <label for="steeringServoPin">Lenkservo (PWM)</label>
          <div class="number-input">
            <input id="steeringServoPin" type="number" inputmode="numeric" min="0" max="40" step="1" aria-label="GPIO-Pin für den Lenkservo" autocomplete="off">
            <span>GPIO</span>
          </div>
        </div>
        <div class="field">
          <label for="headServoPin">Kopfservo (PWM)</label>
          <div class="number-input">
            <input id="headServoPin" type="number" inputmode="numeric" min="0" max="40" step="1" aria-label="GPIO-Pin für den Kopfservo" autocomplete="off">
            <span>GPIO</span>
          </div>
        </div>
      </div>
      <div class="motor-gpio-list" id="motorGpioContainer"></div>
    </section>
    <div class="settings-footer">
      <a class="primary-link" href="/settings" aria-label="Zurück zu den Einstellungen">Zurück</a>
    </div>
  </div>
  <script>
    const statusEl = document.getElementById('status');
    const motorForward = document.getElementById('motorForward');
    const motorReverse = document.getElementById('motorReverse');
    const motorForwardValue = document.getElementById('motorForwardValue');
    const motorReverseValue = document.getElementById('motorReverseValue');
    const steeringLeft = document.getElementById('steeringLeft');
    const steeringMid = document.getElementById('steeringMid');
    const steeringRight = document.getElementById('steeringRight');
    const steeringInputs = [steeringLeft, steeringMid, steeringRight].filter((input) => input);
    const steeringPulseLeft = document.getElementById('steeringPulseLeft');
    const steeringPulseMid = document.getElementById('steeringPulseMid');
    const steeringPulseRight = document.getElementById('steeringPulseRight');
    const steeringPulseInputs = [steeringPulseLeft, steeringPulseMid, steeringPulseRight].filter((input) => input);
    const headLeft = document.getElementById('headLeft');
    const headMid = document.getElementById('headMid');
    const headRight = document.getElementById('headRight');
    const headInputs = [headLeft, headMid, headRight].filter((input) => input);
    const steeringServoPin = document.getElementById('steeringServoPin');
    const headServoPin = document.getElementById('headServoPin');
    const motorGpioContainer = document.getElementById('motorGpioContainer');
    const motorChannelInputs = [];

    let motorConfig = null;
    let steeringConfig = null;
    let steeringPulseConfig = null;
    let headConfig = null;
    let gpioConfig = null;
    let gpioPinMin = 0;
    let gpioPinMax = 27;

    const setStatus = (message, tone = '') => {
      if (!statusEl) {
        return;
      }
      statusEl.textContent = message ?? '';
      statusEl.classList.remove('success', 'error');
      if (tone === 'success') {
        statusEl.classList.add('success');
      } else if (tone === 'error') {
        statusEl.classList.add('error');
      }
    };

    const formatLoadedStatus = (items) => {
      if (!Array.isArray(items)) {
        return '';
      }
      const parts = items.filter((item) => typeof item === 'string' && item.trim() !== '');
      if (parts.length === 0) {
        return '';
      }
      if (parts.length === 1) {
        return `${parts[0]} geladen.`;
      }
      if (parts.length === 2) {
        return `${parts[0]} und ${parts[1]} geladen.`;
      }
      const prefix = parts.slice(0, -1).join(', ');
      const last = parts[parts.length - 1];
      return `${prefix} und ${last} geladen.`;
    };

    const formatMotorPercent = (value) => `${Math.round((Number.parseFloat(value) || 0) * 100)}%`;

    const clampMotorLimit = (value) => {
      if (!motorConfig) {
        return null;
      }
      const { min, max, step } = motorConfig;
      const numeric = Number.parseFloat(value);
      if (!Number.isFinite(numeric)) {
        return null;
      }
      const limited = Math.max(min, Math.min(max, numeric));
      const steps = Math.round((limited - min) / step);
      const quantized = min + steps * step;
      const clamped = Math.max(min, Math.min(max, quantized));
      return Number.parseFloat(clamped.toFixed(4));
    };

    const clampMotorFromSlider = (value) => {
      if (!motorConfig) {
        return null;
      }
      const numeric = Number.parseFloat(value);
      if (!Number.isFinite(numeric)) {
        return null;
      }
      return clampMotorLimit(numeric / 100);
    };

    const syncMotorLimits = (info) => {
      if (!motorForward || !motorReverse || !motorForwardValue || !motorReverseValue) {
        return null;
      }
      if (!info || !Number.isFinite(info.forward) || !Number.isFinite(info.reverse)) {
        motorConfig = null;
        motorForward.disabled = true;
        motorReverse.disabled = true;
        motorForwardValue.textContent = '–';
        motorReverseValue.textContent = '–';
        return null;
      }
      const min = Number.isFinite(info.min) ? info.min : 0;
      const max = Number.isFinite(info.max) ? info.max : 1;
      const step = Number.isFinite(info.step) && info.step > 0 ? info.step : 0.01;
      motorConfig = { min, max, step };
      const sliderMin = Math.round(min * 100);
      const sliderMax = Math.round(max * 100);
      const sliderStep = Math.max(1, Math.round(step * 100));
      motorForward.min = String(sliderMin);
      motorForward.max = String(sliderMax);
      motorForward.step = String(sliderStep);
      motorReverse.min = String(sliderMin);
      motorReverse.max = String(sliderMax);
      motorReverse.step = String(sliderStep);
      const forwardValue = clampMotorLimit(info.forward);
      const reverseValue = clampMotorLimit(info.reverse);
      if (forwardValue === null || reverseValue === null) {
        motorConfig = null;
        motorForward.disabled = true;
        motorReverse.disabled = true;
        motorForwardValue.textContent = '–';
        motorReverseValue.textContent = '–';
        return null;
      }
      motorForward.disabled = false;
      motorReverse.disabled = false;
      motorForward.value = String(Math.round(forwardValue * 100));
      motorReverse.value = String(Math.round(reverseValue * 100));
      motorForwardValue.textContent = formatMotorPercent(forwardValue);
      motorReverseValue.textContent = formatMotorPercent(reverseValue);
      return { forward: forwardValue, reverse: reverseValue };
    };

    const getCurrentMotorValues = () => {
      if (!motorConfig || !motorForward || !motorReverse) {
        return null;
      }
      const forward = clampMotorFromSlider(motorForward.value);
      const reverse = clampMotorFromSlider(motorReverse.value);
      if (forward === null || reverse === null) {
        return null;
      }
      return { forward, reverse };
    };

    const determineAnglePrecision = (step) => {
      if (!Number.isFinite(step) || step <= 0) {
        return 2;
      }
      if (step >= 1) {
        return 0;
      }
      if (step >= 0.1) {
        return 1;
      }
      return 2;
    };

    const quantizeAngle = (value, min, max, step) => {
      const numeric = Number.parseFloat(value);
      if (!Number.isFinite(numeric)) {
        return null;
      }
      const limited = Math.max(min, Math.min(max, numeric));
      if (!Number.isFinite(step) || step <= 0) {
        return Number.parseFloat(limited.toFixed(3));
      }
      const steps = Math.round((limited - min) / step);
      const quantized = min + steps * step;
      const clamped = Math.max(min, Math.min(max, quantized));
      return Number.parseFloat(clamped.toFixed(3));
    };

    const formatAngleInput = (value, precision) => {
      if (!Number.isFinite(value)) {
        return '';
      }
      const digits = Number.isInteger(precision) ? precision : 1;
      const clampedDigits = Math.max(0, Math.min(3, digits));
      const normalized = Number.parseFloat(value.toFixed(clampedDigits));
      return Number.isFinite(normalized) ? String(normalized) : '';
    };

    const quantizePulse = (value, min, max, step) => {
      if (value === undefined || value === null) {
        return null;
      }
      let candidate = value;
      if (typeof candidate === 'string') {
        candidate = candidate.trim();
        if (candidate === '') {
          return null;
        }
        candidate = candidate.replace(',', '.');
      }
      const numeric = Number.parseFloat(candidate);
      if (!Number.isFinite(numeric)) {
        return null;
      }
      const limited = Math.max(min, Math.min(max, numeric));
      if (!Number.isFinite(step) || step <= 0) {
        return Math.round(limited);
      }
      const steps = Math.round((limited - min) / step);
      const quantized = min + steps * step;
      const clamped = Math.max(min, Math.min(max, quantized));
      return Math.round(clamped);
    };

    const formatPulseInput = (value) => {
      if (!Number.isFinite(value)) {
        return '';
      }
      return String(Math.round(value));
    };

    const clampSteeringValue = (rawValue) => {
      if (!steeringConfig) {
        return null;
      }
      if (rawValue === undefined || rawValue === null) {
        return null;
      }
      let candidate = rawValue;
      if (typeof candidate === 'string') {
        candidate = candidate.trim();
        if (candidate === '') {
          return null;
        }
        candidate = candidate.replace(',', '.');
      }
      const { min, max, step } = steeringConfig;
      return quantizeAngle(candidate, min, max, step);
    };

    const clampSteeringPulseValue = (rawValue) => {
      if (!steeringPulseConfig) {
        return null;
      }
      const { min, max, step } = steeringPulseConfig;
      return quantizePulse(rawValue, min, max, step);
    };

    const applySteeringInputs = (values) => {
      if (!steeringConfig) {
        return;
      }
      const precision = steeringConfig.precision ?? 1;
      if (steeringLeft) {
        steeringLeft.value = formatAngleInput(values.left, precision);
      }
      if (steeringMid) {
        steeringMid.value = formatAngleInput(values.mid, precision);
      }
      if (steeringRight) {
        steeringRight.value = formatAngleInput(values.right, precision);
      }
    };

    const revertSteeringInputs = () => {
      if (!steeringConfig || !steeringConfig.values) {
        steeringInputs.forEach((input) => {
          input.value = '';
        });
        return;
      }
      applySteeringInputs(steeringConfig.values);
    };

    const applySteeringPulseInputs = (values) => {
      if (!steeringPulseConfig) {
        return;
      }
      if (steeringPulseLeft) {
        steeringPulseLeft.value = formatPulseInput(values.left);
      }
      if (steeringPulseMid) {
        steeringPulseMid.value = formatPulseInput(values.mid);
      }
      if (steeringPulseRight) {
        steeringPulseRight.value = formatPulseInput(values.right);
      }
    };

    const revertSteeringPulseInputs = () => {
      if (!steeringPulseConfig || !steeringPulseConfig.values) {
        steeringPulseInputs.forEach((input) => {
          input.value = '';
        });
        return;
      }
      applySteeringPulseInputs(steeringPulseConfig.values);
    };

    const syncSteeringAngles = (info) => {
      if (steeringInputs.length === 0) {
        return null;
      }
      if (
        !info ||
        !Number.isFinite(info.left) ||
        !Number.isFinite(info.mid) ||
        !Number.isFinite(info.right)
      ) {
        steeringConfig = null;
        steeringInputs.forEach((input) => {
          input.disabled = true;
          input.value = '';
        });
        return null;
      }
      const min = Number.isFinite(info.min) ? info.min : 0;
      const max = Number.isFinite(info.max) ? info.max : 270;
      const step = Number.isFinite(info.step) && info.step > 0 ? info.step : 0.5;
      const precision = determineAnglePrecision(step);
      const left = quantizeAngle(info.left, min, max, step);
      const mid = quantizeAngle(info.mid, min, max, step);
      const right = quantizeAngle(info.right, min, max, step);
      if (left === null || mid === null || right === null || !(left <= mid && mid <= right)) {
        steeringConfig = null;
        steeringInputs.forEach((input) => {
          input.disabled = true;
          input.value = '';
        });
        return null;
      }
      steeringConfig = {
        min,
        max,
        step,
        precision,
        values: { left, mid, right },
      };
      steeringInputs.forEach((input) => {
        input.disabled = false;
        input.min = String(min);
        input.max = String(max);
        input.step = String(step);
      });
      applySteeringInputs(steeringConfig.values);
      return steeringConfig.values;
    };

    const getCurrentSteeringValues = () => {
      if (!steeringConfig) {
        return null;
      }
      const left = clampSteeringValue(steeringLeft?.value);
      const mid = clampSteeringValue(steeringMid?.value);
      const right = clampSteeringValue(steeringRight?.value);
      if (left === null || mid === null || right === null) {
        return null;
      }
      if (!(left <= mid && mid <= right)) {
        return null;
      }
      return { left, mid, right };
    };

    const syncSteeringPulses = (info) => {
      if (steeringPulseInputs.length === 0) {
        return null;
      }
      const minCandidate = Number.parseFloat(info?.min);
      const maxCandidate = Number.parseFloat(info?.max);
      const stepCandidate = Number.parseFloat(info?.step);
      const min = Number.isFinite(minCandidate) ? minCandidate : 600;
      const max = Number.isFinite(maxCandidate) ? maxCandidate : 2400;
      const rawStep = Number.isFinite(stepCandidate) && stepCandidate > 0 ? stepCandidate : 1;
      const left = quantizePulse(info?.left, min, max, rawStep);
      const mid = quantizePulse(info?.mid, min, max, rawStep);
      const right = quantizePulse(info?.right, min, max, rawStep);
      const monotonicIncreasing = left !== null && mid !== null && right !== null && left <= mid && mid <= right;
      const monotonicDecreasing = left !== null && mid !== null && right !== null && left >= mid && mid >= right;
      if (left === null || mid === null || right === null || (!monotonicIncreasing && !monotonicDecreasing)) {
        steeringPulseConfig = null;
        steeringPulseInputs.forEach((input) => {
          input.disabled = true;
          input.value = '';
        });
        return null;
      }
      steeringPulseConfig = {
        min,
        max,
        step: rawStep,
        values: { left, mid, right },
      };
      steeringPulseInputs.forEach((input) => {
        input.disabled = false;
        input.min = String(min);
        input.max = String(max);
        input.step = String(rawStep);
      });
      applySteeringPulseInputs(steeringPulseConfig.values);
      return steeringPulseConfig.values;
    };

    const getCurrentSteeringPulseValues = () => {
      if (!steeringPulseConfig) {
        return null;
      }
      const left = clampSteeringPulseValue(steeringPulseLeft?.value);
      const mid = clampSteeringPulseValue(steeringPulseMid?.value);
      const right = clampSteeringPulseValue(steeringPulseRight?.value);
      if (left === null || mid === null || right === null) {
        return null;
      }
      if (!((left <= mid && mid <= right) || (left >= mid && mid >= right))) {
        return null;
      }
      return { left, mid, right };
    };

    const clampHeadValue = (rawValue) => {
      if (!headConfig) {
        return null;
      }
      if (rawValue === undefined || rawValue === null) {
        return null;
      }
      let candidate = rawValue;
      if (typeof candidate === 'string') {
        candidate = candidate.trim();
        if (candidate === '') {
          return null;
        }
        candidate = candidate.replace(',', '.');
      }
      const { min, max, step } = headConfig;
      return quantizeAngle(candidate, min, max, step);
    };

    const applyHeadInputs = (values) => {
      if (!headConfig) {
        return;
      }
      const precision = headConfig.precision ?? 1;
      if (headLeft) {
        headLeft.value = formatAngleInput(values.left, precision);
      }
      if (headMid) {
        headMid.value = formatAngleInput(values.mid, precision);
      }
      if (headRight) {
        headRight.value = formatAngleInput(values.right, precision);
      }
    };

    const revertHeadInputs = () => {
      if (!headConfig || !headConfig.values) {
        headInputs.forEach((input) => {
          input.value = '';
        });
        return;
      }
      applyHeadInputs(headConfig.values);
    };

    const syncHeadAngles = (info) => {
      if (headInputs.length === 0) {
        return null;
      }
      if (
        !info ||
        !Number.isFinite(info.left) ||
        !Number.isFinite(info.mid) ||
        !Number.isFinite(info.right)
      ) {
        headConfig = null;
        headInputs.forEach((input) => {
          input.disabled = true;
          input.value = '';
        });
        return null;
      }
      const min = Number.isFinite(info.min) ? info.min : 0;
      const max = Number.isFinite(info.max) ? info.max : 270;
      const step = Number.isFinite(info.step) && info.step > 0 ? info.step : 0.5;
      const precision = determineAnglePrecision(step);
      const left = quantizeAngle(info.left, min, max, step);
      const mid = quantizeAngle(info.mid, min, max, step);
      const right = quantizeAngle(info.right, min, max, step);
      if (left === null || mid === null || right === null || !(left <= mid && mid <= right)) {
        headConfig = null;
        headInputs.forEach((input) => {
          input.disabled = true;
          input.value = '';
        });
        return null;
      }
      headConfig = {
        min,
        max,
        step,
        precision,
        values: { left, mid, right },
      };
      headInputs.forEach((input) => {
        input.disabled = false;
        input.min = String(min);
        input.max = String(max);
        input.step = String(step);
      });
      applyHeadInputs(headConfig.values);
      return headConfig.values;
    };

    const getCurrentHeadValues = () => {
      if (!headConfig) {
        return null;
      }
      const left = clampHeadValue(headLeft?.value);
      const mid = clampHeadValue(headMid?.value);
      const right = clampHeadValue(headRight?.value);
      if (left === null || mid === null || right === null) {
        return null;
      }
      if (!(left <= mid && mid <= right)) {
        return null;
      }
      return { left, mid, right };
    };

    const sanitizePinValue = (value) => {
      if (typeof value === 'number' && Number.isFinite(value)) {
        return Math.trunc(value);
      }
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (trimmed === '') {
          return null;
        }
        const parsed = Number.parseInt(trimmed, 10);
        return Number.isFinite(parsed) ? parsed : null;
      }
      return null;
    };

    const sanitizeMotorChannelSnapshot = (channel) => {
      if (!channel || typeof channel !== 'object') {
        return null;
      }
      const pwm = sanitizePinValue(channel.pwm);
      const dir = sanitizePinValue(channel.dir);
      if (pwm === null || dir === null) {
        return null;
      }
      const rawForward = channel.forward_high;
      let forwardHigh = true;
      if (typeof rawForward === 'boolean') {
        forwardHigh = rawForward;
      } else if (typeof rawForward === 'number' && Number.isFinite(rawForward)) {
        forwardHigh = rawForward !== 0;
      } else if (typeof rawForward === 'string') {
        const normalized = rawForward.trim().toLowerCase();
        if (normalized === '0' || normalized === 'false' || normalized === 'low') {
          forwardHigh = false;
        } else if (normalized === '1' || normalized === 'true' || normalized === 'high') {
          forwardHigh = true;
        }
      }
      return { pwm, dir, forward_high: forwardHigh };
    };

    const sanitizeGpioSnapshot = (info) => {
      if (!info || typeof info !== 'object') {
        return null;
      }
      const steering = sanitizePinValue(info.steering_servo);
      const head = sanitizePinValue(info.head_servo);
      const rawChannels = Array.isArray(info.motor_driver) ? info.motor_driver : [];
      const channels = [];
      rawChannels.forEach((entry) => {
        const sanitized = sanitizeMotorChannelSnapshot(entry);
        if (sanitized) {
          channels.push(sanitized);
        }
      });
      if (steering === null || head === null || channels.length === 0) {
        return null;
      }
      return {
        steering_servo: steering,
        head_servo: head,
        motor_driver: channels,
      };
    };

    const clampPinValue = (rawValue, minVal, maxVal) => {
      if (rawValue === undefined || rawValue === null) {
        return null;
      }
      let candidate = rawValue;
      if (typeof candidate === 'string') {
        const trimmed = candidate.trim();
        if (trimmed === '') {
          return null;
        }
        candidate = trimmed;
      }
      const parsed = Number.parseInt(candidate, 10);
      if (!Number.isFinite(parsed)) {
        return null;
      }
      const lower = Number.isFinite(minVal) ? minVal : 0;
      const upper = Number.isFinite(maxVal) ? maxVal : 27;
      const limited = Math.min(Math.max(parsed, lower), upper);
      return limited;
    };

    const enforcePinRange = (input) => {
      if (!input) {
        return;
      }
      const minVal = gpioConfig ? gpioConfig.minPin : gpioPinMin;
      const maxVal = gpioConfig ? gpioConfig.maxPin : gpioPinMax;
      const clamped = clampPinValue(input.value, minVal, maxVal);
      if (clamped === null) {
        return;
      }
      const normalized = String(clamped);
      if (input.value !== normalized) {
        input.value = normalized;
      }
    };

    const disableGpioInputs = () => {
      gpioConfig = null;
      if (steeringServoPin) {
        steeringServoPin.disabled = true;
        steeringServoPin.value = '';
      }
      if (headServoPin) {
        headServoPin.disabled = true;
        headServoPin.value = '';
      }
      if (motorGpioContainer) {
        motorGpioContainer.innerHTML = '';
      }
      motorChannelInputs.length = 0;
    };

    function handleGpioChange() {
      const values = getCurrentGpioValues();
      if (!values) {
        setStatus('Ungültige GPIO-Konfiguration. Bitte prüfen.', 'error');
        revertGpioInputs();
        return;
      }
      const currentSerialized = gpioConfig ? JSON.stringify(gpioConfig.values) : '';
      const nextSerialized = JSON.stringify(values);
      if (currentSerialized === nextSerialized) {
        if (gpioConfig && gpioConfig.values) {
          applyGpioInputs(gpioConfig.values);
        }
        return;
      }
      saveGpioSettings(values);
    }

    const ensureMotorChannelInputs = (count) => {
      if (!motorGpioContainer) {
        motorChannelInputs.length = 0;
        return;
      }
      if (!Number.isInteger(count) || count <= 0) {
        motorGpioContainer.innerHTML = '';
        motorChannelInputs.length = 0;
        return;
      }
      if (motorChannelInputs.length === count && motorGpioContainer.childElementCount === count) {
        return;
      }
      motorGpioContainer.innerHTML = '';
      motorChannelInputs.length = 0;
      for (let idx = 0; idx < count; idx += 1) {
        const channelCard = document.createElement('div');
        channelCard.className = 'motor-channel';
        const heading = document.createElement('h3');
        heading.textContent = `MDD10A Kanal ${idx + 1}`;
        channelCard.appendChild(heading);
        const grid = document.createElement('div');
        grid.className = 'motor-channel-grid';
        channelCard.appendChild(grid);

        const createNumberField = (id, labelText) => {
          const field = document.createElement('div');
          field.className = 'field';
          const label = document.createElement('label');
          label.setAttribute('for', id);
          label.textContent = labelText;
          field.appendChild(label);
          const wrapper = document.createElement('div');
          wrapper.className = 'number-input';
          const input = document.createElement('input');
          input.type = 'number';
          input.id = id;
          input.inputMode = 'numeric';
          input.autocomplete = 'off';
          input.step = '1';
          input.disabled = true;
          input.setAttribute('aria-label', `GPIO-Pin für ${labelText}`);
          wrapper.appendChild(input);
          const suffix = document.createElement('span');
          suffix.textContent = 'GPIO';
          wrapper.appendChild(suffix);
          field.appendChild(wrapper);
          return { field, input };
        };

        const pwmId = `motorChannel${idx + 1}Pwm`;
        const pwmField = createNumberField(pwmId, 'PWM');
        grid.appendChild(pwmField.field);

        const dirId = `motorChannel${idx + 1}Dir`;
        const dirField = createNumberField(dirId, 'Richtung');
        grid.appendChild(dirField.field);

        const modeField = document.createElement('div');
        modeField.className = 'field';
        const modeLabel = document.createElement('label');
        const forwardId = `motorChannel${idx + 1}ForwardHigh`;
        modeLabel.setAttribute('for', forwardId);
        modeLabel.textContent = 'Vorwärtspegel';
        modeField.appendChild(modeLabel);
        const select = document.createElement('select');
        select.id = forwardId;
        select.disabled = true;
        select.setAttribute('aria-label', 'Logikpegel für Vorwärtsfahrt');
        const optionHigh = document.createElement('option');
        optionHigh.value = '1';
        optionHigh.textContent = 'High = Vorwärts';
        select.appendChild(optionHigh);
        const optionLow = document.createElement('option');
        optionLow.value = '0';
        optionLow.textContent = 'Low = Vorwärts';
        select.appendChild(optionLow);
        modeField.appendChild(select);
        grid.appendChild(modeField);

        motorGpioContainer.appendChild(channelCard);

        pwmField.input.addEventListener('input', () => enforcePinRange(pwmField.input));
        pwmField.input.addEventListener('change', handleGpioChange);
        dirField.input.addEventListener('input', () => enforcePinRange(dirField.input));
        dirField.input.addEventListener('change', handleGpioChange);
        select.addEventListener('change', handleGpioChange);

        motorChannelInputs.push({
          pwm: pwmField.input,
          dir: dirField.input,
          forwardHigh: select,
        });
      }
    };

    const applyGpioInputs = (values) => {
      if (!values) {
        return;
      }
      if (steeringServoPin) {
        steeringServoPin.disabled = false;
        steeringServoPin.min = String(gpioPinMin);
        steeringServoPin.max = String(gpioPinMax);
        steeringServoPin.value = String(values.steering_servo ?? '');
      }
      if (headServoPin) {
        headServoPin.disabled = false;
        headServoPin.min = String(gpioPinMin);
        headServoPin.max = String(gpioPinMax);
        headServoPin.value = String(values.head_servo ?? '');
      }
      motorChannelInputs.forEach((entry, idx) => {
        const channel = values.motor_driver[idx];
        if (!channel) {
          entry.pwm.disabled = true;
          entry.dir.disabled = true;
          entry.forwardHigh.disabled = true;
          entry.pwm.value = '';
          entry.dir.value = '';
          entry.forwardHigh.value = '1';
          return;
        }
        entry.pwm.disabled = false;
        entry.pwm.min = String(gpioPinMin);
        entry.pwm.max = String(gpioPinMax);
        entry.pwm.value = String(channel.pwm);
        entry.dir.disabled = false;
        entry.dir.min = String(gpioPinMin);
        entry.dir.max = String(gpioPinMax);
        entry.dir.value = String(channel.dir);
        entry.forwardHigh.disabled = false;
        entry.forwardHigh.value = channel.forward_high ? '1' : '0';
      });
    };

    const revertGpioInputs = () => {
      if (!gpioConfig || !gpioConfig.values) {
        if (steeringServoPin) {
          steeringServoPin.value = '';
        }
        if (headServoPin) {
          headServoPin.value = '';
        }
        motorChannelInputs.forEach((entry) => {
          entry.pwm.value = '';
          entry.dir.value = '';
          entry.forwardHigh.value = '1';
        });
        return;
      }
      applyGpioInputs(gpioConfig.values);
    };

    const syncGpioSettings = (info) => {
      const sanitized = sanitizeGpioSnapshot(info);
      const minCandidate = sanitizePinValue(info?.pin_min);
      const maxCandidate = sanitizePinValue(info?.pin_max);
      gpioPinMin = Number.isInteger(minCandidate) ? minCandidate : 0;
      gpioPinMax = Number.isInteger(maxCandidate) ? maxCandidate : 27;
      if (!sanitized) {
        disableGpioInputs();
        return null;
      }
      ensureMotorChannelInputs(sanitized.motor_driver.length);
      if (motorChannelInputs.length !== sanitized.motor_driver.length) {
        disableGpioInputs();
        return null;
      }
      applyGpioInputs(sanitized);
      gpioConfig = {
        minPin: gpioPinMin,
        maxPin: gpioPinMax,
        values: sanitized,
      };
      return sanitized;
    };

    const getCurrentGpioValues = () => {
      if (!gpioConfig) {
        return null;
      }
      if (!steeringServoPin || !headServoPin) {
        return null;
      }
      const minVal = gpioConfig.minPin ?? gpioPinMin;
      const maxVal = gpioConfig.maxPin ?? gpioPinMax;
      const steering = clampPinValue(steeringServoPin.value, minVal, maxVal);
      const head = clampPinValue(headServoPin.value, minVal, maxVal);
      if (steering === null || head === null) {
        return null;
      }
      if (motorChannelInputs.length !== gpioConfig.values.motor_driver.length) {
        return null;
      }
      const channels = [];
      for (let idx = 0; idx < motorChannelInputs.length; idx += 1) {
        const entry = motorChannelInputs[idx];
        const pwm = clampPinValue(entry.pwm.value, minVal, maxVal);
        const dir = clampPinValue(entry.dir.value, minVal, maxVal);
        if (pwm === null || dir === null) {
          return null;
        }
        const forwardHigh = entry.forwardHigh.value === '0' ? false : true;
        channels.push({ pwm, dir, forward_high: forwardHigh });
      }
      return {
        steering_servo: steering,
        head_servo: head,
        motor_driver: channels,
      };
    };

    async function saveGpioSettings(settings) {
      if (!settings) {
        return;
      }
      try {
        setStatus('Speichere GPIO-Einstellungen …');
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ gpio: settings }),
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncMotorLimits(data.motor_limits);
        syncSteeringAngles(data.steering_angles);
        syncSteeringPulses(data.steering_pulses);
        syncHeadAngles(data.head_angles);
        const updated = syncGpioSettings(data.gpio);
        if (updated) {
          setStatus('GPIO-Einstellungen gespeichert.', 'success');
        } else {
          setStatus('GPIO-Einstellungen aktualisiert.', 'success');
        }
      } catch (err) {
        console.error('Speichern der GPIO-Einstellungen fehlgeschlagen', err);
        revertGpioInputs();
        setStatus('GPIO-Einstellungen konnten nicht gespeichert werden.', 'error');
      }
    }

    async function loadAdvancedSettings() {
      try {
        setStatus('Lade Einstellungen …');
        const resp = await fetch('/api/state');
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        const motorValues = syncMotorLimits(data.motor_limits);
        const steeringValues = syncSteeringAngles(data.steering_angles);
        const steeringPulseValues = syncSteeringPulses(data.steering_pulses);
        const headValues = syncHeadAngles(data.head_angles);
        const gpioValues = syncGpioSettings(data.gpio);
        const loadedSections = [];
        if (motorValues) {
          loadedSections.push('Motor-Grenzen');
        }
        if (steeringValues) {
          loadedSections.push('Lenkwinkel');
        }
        if (steeringPulseValues) {
          loadedSections.push('Servo-Kalibrierung');
        }
        if (headValues) {
          loadedSections.push('Kopfwinkel');
        }
        if (gpioValues) {
          loadedSections.push('GPIO-Belegung');
        }
        const statusMessage = formatLoadedStatus(loadedSections);
        if (statusMessage) {
          setStatus(statusMessage, 'success');
        } else {
          setStatus('Keine erweiterten Einstellungen verfügbar.', 'error');
        }
      } catch (err) {
        console.error('Laden der erweiterten Einstellungen fehlgeschlagen', err);
        setStatus('Erweiterte Einstellungen konnten nicht geladen werden.', 'error');
        syncMotorLimits(null);
        syncSteeringAngles(null);
        syncSteeringPulses(null);
        syncHeadAngles(null);
        syncGpioSettings(null);
      }
    }

    async function saveMotorLimits(forward, reverse) {
      if (!motorForward || !motorReverse) {
        return;
      }
      try {
        setStatus('Speichere Motor-Grenzen …');
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ motor_limits: { forward, reverse } })
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncSteeringAngles(data.steering_angles);
        syncSteeringPulses(data.steering_pulses);
        syncHeadAngles(data.head_angles);
        syncGpioSettings(data.gpio);
        const updated = syncMotorLimits(data.motor_limits);
        if (updated) {
          setStatus('Motor-Grenzen gespeichert.', 'success');
        } else {
          setStatus('Motor-Grenzen konnten nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern der Motor-Grenzen fehlgeschlagen', err);
        setStatus('Motor-Grenzen konnten nicht gespeichert werden.', 'error');
      }
    }

    async function saveSteeringAngles(values) {
      if (!values) {
        return;
      }
      try {
        setStatus('Speichere Lenkwinkel …');
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ steering_angles: values })
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        const updated = syncSteeringAngles(data.steering_angles);
        syncSteeringPulses(data.steering_pulses);
        syncMotorLimits(data.motor_limits);
        syncHeadAngles(data.head_angles);
        syncGpioSettings(data.gpio);
        if (updated) {
          setStatus('Lenkwinkel gespeichert.', 'success');
        } else {
          setStatus('Lenkwinkel konnten nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern der Lenkwinkel fehlgeschlagen', err);
        revertSteeringInputs();
        setStatus('Lenkwinkel konnten nicht gespeichert werden.', 'error');
      }
    }

    async function saveSteeringPulses(values) {
      if (!values) {
        return;
      }
      try {
        setStatus('Speichere Servo-Kalibrierung …');
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ steering_pulses: values })
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncMotorLimits(data.motor_limits);
        const updated = syncSteeringPulses(data.steering_pulses);
        syncSteeringAngles(data.steering_angles);
        syncHeadAngles(data.head_angles);
        syncGpioSettings(data.gpio);
        if (updated) {
          setStatus('Servo-Kalibrierung gespeichert.', 'success');
        } else {
          setStatus('Servo-Kalibrierung konnte nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern der Servo-Kalibrierung fehlgeschlagen', err);
        revertSteeringPulseInputs();
        setStatus('Servo-Kalibrierung konnte nicht gespeichert werden.', 'error');
      }
    }

    async function saveHeadAngles(values) {
      if (!values) {
        return;
      }
      try {
        setStatus('Speichere Kopfwinkel …');
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ head_angles: values })
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        const updated = syncHeadAngles(data.head_angles);
        syncMotorLimits(data.motor_limits);
        syncSteeringAngles(data.steering_angles);
        syncSteeringPulses(data.steering_pulses);
        syncGpioSettings(data.gpio);
        if (updated) {
          setStatus('Kopfwinkel gespeichert.', 'success');
        } else {
          setStatus('Kopfwinkel konnten nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern der Kopfwinkel fehlgeschlagen', err);
        revertHeadInputs();
        setStatus('Kopfwinkel konnten nicht gespeichert werden.', 'error');
      }
    }

    if (steeringInputs.length > 0) {
      steeringInputs.forEach((input) => {
        input.disabled = true;
        input.value = '';
      });
    }

    if (steeringPulseInputs.length > 0) {
      steeringPulseInputs.forEach((input) => {
        input.disabled = true;
        input.value = '';
      });
    }

    if (headInputs.length > 0) {
      headInputs.forEach((input) => {
        input.disabled = true;
        input.value = '';
      });
    }

    if (steeringServoPin) {
      steeringServoPin.disabled = true;
      steeringServoPin.value = '';
      steeringServoPin.addEventListener('input', () => enforcePinRange(steeringServoPin));
      steeringServoPin.addEventListener('change', handleGpioChange);
    }

    if (headServoPin) {
      headServoPin.disabled = true;
      headServoPin.value = '';
      headServoPin.addEventListener('input', () => enforcePinRange(headServoPin));
      headServoPin.addEventListener('change', handleGpioChange);
    }

    disableGpioInputs();

    if (motorForward) {
      motorForward.disabled = true;
      motorForward.value = '0';
    }
    if (motorReverse) {
      motorReverse.disabled = true;
      motorReverse.value = '0';
    }
    if (motorForwardValue) {
      motorForwardValue.textContent = '–';
    }
    if (motorReverseValue) {
      motorReverseValue.textContent = '–';
    }

    if (motorForward && motorForwardValue) {
      motorForward.addEventListener('input', () => {
        const value = clampMotorFromSlider(motorForward.value);
        motorForwardValue.textContent = value === null ? '–' : formatMotorPercent(value);
      });
      motorForward.addEventListener('change', () => {
        const values = getCurrentMotorValues();
        if (!values) {
          return;
        }
        motorForward.value = String(Math.round(values.forward * 100));
        motorForwardValue.textContent = formatMotorPercent(values.forward);
        motorReverse.value = String(Math.round(values.reverse * 100));
        motorReverseValue.textContent = formatMotorPercent(values.reverse);
        saveMotorLimits(values.forward, values.reverse);
      });
    }

    if (motorReverse && motorReverseValue) {
      motorReverse.addEventListener('input', () => {
        const value = clampMotorFromSlider(motorReverse.value);
        motorReverseValue.textContent = value === null ? '–' : formatMotorPercent(value);
      });
      motorReverse.addEventListener('change', () => {
        const values = getCurrentMotorValues();
        if (!values) {
          return;
        }
        motorForward.value = String(Math.round(values.forward * 100));
        motorForwardValue.textContent = formatMotorPercent(values.forward);
        motorReverse.value = String(Math.round(values.reverse * 100));
        motorReverseValue.textContent = formatMotorPercent(values.reverse);
        saveMotorLimits(values.forward, values.reverse);
      });
    }

    if (steeringInputs.length > 0) {
      const handleSteeringChange = () => {
        const values = getCurrentSteeringValues();
        if (!values) {
          setStatus('Ungültige Lenkwinkel. Bitte Werte prüfen.', 'error');
          revertSteeringInputs();
          return;
        }
        if (
          steeringConfig &&
          steeringConfig.values &&
          values.left === steeringConfig.values.left &&
          values.mid === steeringConfig.values.mid &&
          values.right === steeringConfig.values.right
        ) {
          applySteeringInputs(steeringConfig.values);
          return;
        }
        applySteeringInputs(values);
        saveSteeringAngles(values);
      };
      steeringInputs.forEach((input) => {
        input.addEventListener('input', () => {
          if (!steeringConfig) {
            return;
          }
          const raw = input.value;
          if (raw === undefined || raw === null) {
            return;
          }
          const normalized = String(raw).trim();
          if (
            normalized === '' ||
            normalized.endsWith('.') ||
            normalized.endsWith(',') ||
            normalized === '-' ||
            normalized === '+'
          ) {
            return;
          }
          const value = clampSteeringValue(normalized);
          if (value === null) {
            return;
          }
          const formatted = formatAngleInput(value, steeringConfig.precision);
          if (formatted !== raw) {
            input.value = formatted;
          }
        });
        input.addEventListener('change', handleSteeringChange);
      });
    }

    if (steeringPulseInputs.length > 0) {
      const handleSteeringPulseChange = () => {
        const values = getCurrentSteeringPulseValues();
        if (!values) {
          setStatus('Ungültige Servo-Kalibrierung. Bitte Werte prüfen.', 'error');
          revertSteeringPulseInputs();
          return;
        }
        if (
          steeringPulseConfig &&
          steeringPulseConfig.values &&
          values.left === steeringPulseConfig.values.left &&
          values.mid === steeringPulseConfig.values.mid &&
          values.right === steeringPulseConfig.values.right
        ) {
          applySteeringPulseInputs(steeringPulseConfig.values);
          return;
        }
        applySteeringPulseInputs(values);
        saveSteeringPulses(values);
      };
      steeringPulseInputs.forEach((input) => {
        input.addEventListener('input', () => {
          if (!steeringPulseConfig) {
            return;
          }
          const raw = input.value;
          if (raw === undefined || raw === null) {
            return;
          }
          const normalized = String(raw).trim();
          if (
            normalized === '' ||
            normalized.endsWith('.') ||
            normalized.endsWith(',') ||
            normalized === '-' ||
            normalized === '+'
          ) {
            return;
          }
          const value = clampSteeringPulseValue(normalized);
          if (value === null) {
            return;
          }
          const formatted = formatPulseInput(value);
          if (formatted !== raw) {
            input.value = formatted;
          }
        });
        input.addEventListener('change', handleSteeringPulseChange);
      });
    }

    if (headInputs.length > 0) {
      const handleHeadChange = () => {
        const values = getCurrentHeadValues();
        if (!values) {
          setStatus('Ungültige Kopfwinkel. Bitte Werte prüfen.', 'error');
          revertHeadInputs();
          return;
        }
        if (
          headConfig &&
          headConfig.values &&
          values.left === headConfig.values.left &&
          values.mid === headConfig.values.mid &&
          values.right === headConfig.values.right
        ) {
          applyHeadInputs(headConfig.values);
          return;
        }
        applyHeadInputs(values);
        saveHeadAngles(values);
      };
      headInputs.forEach((input) => {
        input.addEventListener('input', () => {
          if (!headConfig) {
            return;
          }
          const raw = input.value;
          if (raw === undefined || raw === null) {
            return;
          }
          const normalized = String(raw).trim();
          if (
            normalized === '' ||
            normalized.endsWith('.') ||
            normalized.endsWith(',') ||
            normalized === '-' ||
            normalized === '+'
          ) {
            return;
          }
          const value = clampHeadValue(normalized);
          if (value === null) {
            return;
          }
          const formatted = formatAngleInput(value, headConfig.precision);
          if (formatted !== raw) {
            input.value = formatted;
          }
        });
        input.addEventListener('change', handleHeadChange);
      });
    }

    loadAdvancedSettings();
  </script>
</body>
</html>
