<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Weitere Einstellungen · Saw Tricycle</title>
  <style>
    :root {
      color-scheme: dark;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #0d0d0d;
      color: #f2f2f2;
      margin: 0;
      min-height: 100vh;
      min-height: 100dvh;
      padding: calc(1.4rem + var(--safe-top)) calc(1.4rem + var(--safe-right)) calc(1.4rem + var(--safe-bottom)) calc(1.4rem + var(--safe-left));
      display: flex;
      justify-content: center;
      align-items: center;
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }
    .settings-card {
      width: 100%;
      max-width: 520px;
      background: #151515;
      border-radius: 16px;
      padding: clamp(1.2rem, 4vw + 0.4rem, 1.8rem);
      box-shadow: 0 0 40px rgba(0,0,0,0.45);
      display: flex;
      flex-direction: column;
      gap: 1.4rem;
    }
    .settings-header {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .back-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 42px;
      height: 42px;
      border-radius: 12px;
      background: rgba(229,9,20,0.16);
      border: 1px solid rgba(229,9,20,0.3);
      color: #fff;
      text-decoration: none;
      transition: background 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
    }
    .back-button:hover {
      background: rgba(229,9,20,0.28);
      border-color: rgba(229,9,20,0.55);
    }
    .back-button:active {
      transform: translateY(1px);
    }
    .settings-header h1 {
      margin: 0;
      font-size: clamp(1.25rem, 3vw, 1.7rem);
      font-weight: 600;
    }
    .settings-section {
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }
    .settings-section .field {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }
    .settings-section h2 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }
    .settings-section p {
      margin: 0;
      line-height: 1.5;
      color: #d5d5d5;
      font-size: 0.95rem;
    }
    .settings-section ul {
      margin: 0;
      padding-left: 1.1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      color: #e6e6e6;
      font-size: 0.95rem;
    }
    .settings-section li {
      line-height: 1.45;
    }
    .settings-section p.hint {
      color: #bbb;
      font-size: 0.9rem;
    }
    .status-container {
      border-radius: 12px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 0.75rem 1rem;
      font-size: 0.95rem;
      color: #bbb;
    }
    .status-container + .settings-section {
      margin-top: -0.2rem;
    }
    .status {
      margin: 0;
      min-height: 1.2em;
    }
    .status.success { color: #63f58c; }
    .status.error { color: #ff7a7a; }
    .steering-grid {
      display: grid;
      gap: 0.75rem;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }
    .number-input {
      display: flex;
      align-items: center;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 0.35rem 0.6rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .number-input input {
      flex: 1 1 auto;
      background: transparent;
      border: none;
      color: inherit;
      font: inherit;
      min-width: 0;
      padding: 0;
      -moz-appearance: textfield;
    }
    .number-input input:focus {
      outline: none;
    }
    .number-input input::-webkit-outer-spin-button,
    .number-input input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    .number-input span {
      margin-left: 0.35rem;
      opacity: 0.7;
      font-size: 0.9rem;
    }
    .number-input:focus-within {
      border-color: rgba(229,9,20,0.55);
      box-shadow: 0 0 0 3px rgba(229,9,20,0.2);
    }
    .motor-limits {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 0.9rem;
    }
    input[type="range"] {
      width: 100%;
      accent-color: #e50914;
    }
    output {
      min-width: 3ch;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .settings-footer {
      display: flex;
      justify-content: flex-end;
    }
    .primary-link {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      border-radius: 12px;
      padding: 0.55rem 1.1rem;
      background: rgba(229,9,20,0.16);
      border: 1px solid rgba(229,9,20,0.4);
      color: #fff;
      font-size: 0.95rem;
      font-weight: 600;
      text-decoration: none;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    .primary-link:hover {
      background: rgba(229,9,20,0.28);
      border-color: rgba(229,9,20,0.55);
    }
    .primary-link:active {
      transform: translateY(1px);
    }
    @media (max-width: 640px) {
      body {
        padding: calc(1rem + var(--safe-top)) calc(1rem + var(--safe-right)) calc(1rem + var(--safe-bottom)) calc(1rem + var(--safe-left));
      }
      .settings-card {
        border-radius: 12px;
      }
    }
    @media (orientation: landscape) and (max-height: 520px) {
      body {
        padding: calc(0.7rem + var(--safe-top)) calc(0.75rem + var(--safe-right)) calc(0.7rem + var(--safe-bottom)) calc(0.75rem + var(--safe-left));
        align-items: stretch;
      }
      .settings-card {
        padding: 0.95rem;
        gap: 1rem;
        max-height: calc(100dvh - var(--safe-top) - var(--safe-bottom) - 1.2rem);
        overflow-y: auto;
        overscroll-behavior: contain;
      }
      .settings-section {
        padding: 1rem;
        gap: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <div class="settings-card">
    <div class="settings-header">
      <a class="back-button" href="/settings" aria-label="Zurück zu den Einstellungen" title="Zurück">⟵</a>
      <h1>Weitere Einstellungen</h1>
    </div>
    <div class="status-container" role="status" aria-live="polite">
      <p id="status" class="status"></p>
    </div>
    <section class="settings-section" id="steeringAngles">
      <h2>Lenkwinkel</h2>
      <p class="hint">Definiert Mittelstellung und maximale Ausschläge des Servos.</p>
      <div class="steering-grid">
        <div class="field">
          <label for="steeringLeft">Links (max.)</label>
          <div class="number-input">
            <input id="steeringLeft" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Maximaler Lenkwinkel nach links" autocomplete="off">
            <span>°</span>
          </div>
        </div>
        <div class="field">
          <label for="steeringMid">Mitte</label>
          <div class="number-input">
            <input id="steeringMid" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Neutralstellung des Lenkservos" autocomplete="off">
            <span>°</span>
          </div>
        </div>
        <div class="field">
          <label for="steeringRight">Rechts (max.)</label>
          <div class="number-input">
            <input id="steeringRight" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Maximaler Lenkwinkel nach rechts" autocomplete="off">
            <span>°</span>
          </div>
        </div>
      </div>
    </section>
    <section class="settings-section" id="headAngles">
      <h2>Kopfwinkel</h2>
      <p class="hint">Einstellbare Positionen für das Kopf-Servo (links, Mitte, rechts).</p>
      <div class="steering-grid">
        <div class="field">
          <label for="headLeft">Links (max.)</label>
          <div class="number-input">
            <input id="headLeft" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Maximaler Kopfwinkel nach links" autocomplete="off">
            <span>°</span>
          </div>
        </div>
        <div class="field">
          <label for="headMid">Mitte</label>
          <div class="number-input">
            <input id="headMid" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Neutralstellung des Kopfservos" autocomplete="off">
            <span>°</span>
          </div>
        </div>
        <div class="field">
          <label for="headRight">Rechts (max.)</label>
          <div class="number-input">
            <input id="headRight" type="number" inputmode="decimal" min="0" max="270" step="0.5" aria-label="Maximaler Kopfwinkel nach rechts" autocomplete="off">
            <span>°</span>
          </div>
        </div>
      </div>
    </section>
    <section class="settings-section">
      <h2>Motorgrenzen</h2>
      <p class="hint">Begrenzt den maximalen PWM-Anteil für den DC-Motor (0–100&nbsp;%).</p>
      <div class="motor-limits">
        <label for="motorForward">Vorwärts</label>
        <div class="slider-row">
          <input id="motorForward" type="range" min="0" max="100" step="1" aria-label="Vorwärtslimit einstellen">
          <output id="motorForwardValue" for="motorForward">–</output>
        </div>
      </div>
      <div class="motor-limits">
        <label for="motorReverse">Rückwärts</label>
        <div class="slider-row">
          <input id="motorReverse" type="range" min="0" max="100" step="1" aria-label="Rückwärtslimit einstellen">
          <output id="motorReverseValue" for="motorReverse">–</output>
        </div>
      </div>
    </section>
    <section class="settings-section">
      <h2>Erweiterte Optionen</h2>
      <p>Hier können künftig zusätzliche Einstellungen und Verwaltungsfunktionen für das Saw Tricycle bereitgestellt werden.</p>
      <p>Nutze diese Seite, um erweiterte Konfigurationsmöglichkeiten oder Diagnosehinweise zu dokumentieren.</p>
    </section>
    <section class="settings-section">
      <h2>Tipps für Administratoren</h2>
      <ul>
        <li>Notiere hier geplante Features oder Befehle, die über die Standardoberfläche hinausgehen.</li>
        <li>Verlinke relevante Dokumentationen oder Support-Kanäle für Wartungsaufgaben.</li>
        <li>Halte individuelle Anpassungen fest, damit alle Teammitglieder informiert bleiben.</li>
      </ul>
    </section>
    <div class="settings-footer">
      <a class="primary-link" href="/settings" aria-label="Zurück zu den Einstellungen">Zurück</a>
    </div>
  </div>
  <script>
    const statusEl = document.getElementById('status');
    const motorForward = document.getElementById('motorForward');
    const motorReverse = document.getElementById('motorReverse');
    const motorForwardValue = document.getElementById('motorForwardValue');
    const motorReverseValue = document.getElementById('motorReverseValue');
    const steeringLeft = document.getElementById('steeringLeft');
    const steeringMid = document.getElementById('steeringMid');
    const steeringRight = document.getElementById('steeringRight');
    const steeringInputs = [steeringLeft, steeringMid, steeringRight].filter((input) => input);
    const headLeft = document.getElementById('headLeft');
    const headMid = document.getElementById('headMid');
    const headRight = document.getElementById('headRight');
    const headInputs = [headLeft, headMid, headRight].filter((input) => input);

    let motorConfig = null;
    let steeringConfig = null;
    let headConfig = null;

    const setStatus = (message, tone = '') => {
      if (!statusEl) {
        return;
      }
      statusEl.textContent = message ?? '';
      statusEl.classList.remove('success', 'error');
      if (tone === 'success') {
        statusEl.classList.add('success');
      } else if (tone === 'error') {
        statusEl.classList.add('error');
      }
    };

    const formatLoadedStatus = (items) => {
      if (!Array.isArray(items)) {
        return '';
      }
      const parts = items.filter((item) => typeof item === 'string' && item.trim() !== '');
      if (parts.length === 0) {
        return '';
      }
      if (parts.length === 1) {
        return `${parts[0]} geladen.`;
      }
      if (parts.length === 2) {
        return `${parts[0]} und ${parts[1]} geladen.`;
      }
      const prefix = parts.slice(0, -1).join(', ');
      const last = parts[parts.length - 1];
      return `${prefix} und ${last} geladen.`;
    };

    const formatMotorPercent = (value) => `${Math.round((Number.parseFloat(value) || 0) * 100)}%`;

    const clampMotorLimit = (value) => {
      if (!motorConfig) {
        return null;
      }
      const { min, max, step } = motorConfig;
      const numeric = Number.parseFloat(value);
      if (!Number.isFinite(numeric)) {
        return null;
      }
      const limited = Math.max(min, Math.min(max, numeric));
      const steps = Math.round((limited - min) / step);
      const quantized = min + steps * step;
      const clamped = Math.max(min, Math.min(max, quantized));
      return Number.parseFloat(clamped.toFixed(4));
    };

    const clampMotorFromSlider = (value) => {
      if (!motorConfig) {
        return null;
      }
      const numeric = Number.parseFloat(value);
      if (!Number.isFinite(numeric)) {
        return null;
      }
      return clampMotorLimit(numeric / 100);
    };

    const syncMotorLimits = (info) => {
      if (!motorForward || !motorReverse || !motorForwardValue || !motorReverseValue) {
        return null;
      }
      if (!info || !Number.isFinite(info.forward) || !Number.isFinite(info.reverse)) {
        motorConfig = null;
        motorForward.disabled = true;
        motorReverse.disabled = true;
        motorForwardValue.textContent = '–';
        motorReverseValue.textContent = '–';
        return null;
      }
      const min = Number.isFinite(info.min) ? info.min : 0;
      const max = Number.isFinite(info.max) ? info.max : 1;
      const step = Number.isFinite(info.step) && info.step > 0 ? info.step : 0.01;
      motorConfig = { min, max, step };
      const sliderMin = Math.round(min * 100);
      const sliderMax = Math.round(max * 100);
      const sliderStep = Math.max(1, Math.round(step * 100));
      motorForward.min = String(sliderMin);
      motorForward.max = String(sliderMax);
      motorForward.step = String(sliderStep);
      motorReverse.min = String(sliderMin);
      motorReverse.max = String(sliderMax);
      motorReverse.step = String(sliderStep);
      const forwardValue = clampMotorLimit(info.forward);
      const reverseValue = clampMotorLimit(info.reverse);
      if (forwardValue === null || reverseValue === null) {
        motorConfig = null;
        motorForward.disabled = true;
        motorReverse.disabled = true;
        motorForwardValue.textContent = '–';
        motorReverseValue.textContent = '–';
        return null;
      }
      motorForward.disabled = false;
      motorReverse.disabled = false;
      motorForward.value = String(Math.round(forwardValue * 100));
      motorReverse.value = String(Math.round(reverseValue * 100));
      motorForwardValue.textContent = formatMotorPercent(forwardValue);
      motorReverseValue.textContent = formatMotorPercent(reverseValue);
      return { forward: forwardValue, reverse: reverseValue };
    };

    const getCurrentMotorValues = () => {
      if (!motorConfig || !motorForward || !motorReverse) {
        return null;
      }
      const forward = clampMotorFromSlider(motorForward.value);
      const reverse = clampMotorFromSlider(motorReverse.value);
      if (forward === null || reverse === null) {
        return null;
      }
      return { forward, reverse };
    };

    const determineAnglePrecision = (step) => {
      if (!Number.isFinite(step) || step <= 0) {
        return 2;
      }
      if (step >= 1) {
        return 0;
      }
      if (step >= 0.1) {
        return 1;
      }
      return 2;
    };

    const quantizeAngle = (value, min, max, step) => {
      const numeric = Number.parseFloat(value);
      if (!Number.isFinite(numeric)) {
        return null;
      }
      const limited = Math.max(min, Math.min(max, numeric));
      if (!Number.isFinite(step) || step <= 0) {
        return Number.parseFloat(limited.toFixed(3));
      }
      const steps = Math.round((limited - min) / step);
      const quantized = min + steps * step;
      const clamped = Math.max(min, Math.min(max, quantized));
      return Number.parseFloat(clamped.toFixed(3));
    };

    const formatAngleInput = (value, precision) => {
      if (!Number.isFinite(value)) {
        return '';
      }
      const digits = Number.isInteger(precision) ? precision : 1;
      const clampedDigits = Math.max(0, Math.min(3, digits));
      const normalized = Number.parseFloat(value.toFixed(clampedDigits));
      return Number.isFinite(normalized) ? String(normalized) : '';
    };

    const clampSteeringValue = (rawValue) => {
      if (!steeringConfig) {
        return null;
      }
      if (rawValue === undefined || rawValue === null) {
        return null;
      }
      let candidate = rawValue;
      if (typeof candidate === 'string') {
        candidate = candidate.trim();
        if (candidate === '') {
          return null;
        }
        candidate = candidate.replace(',', '.');
      }
      const { min, max, step } = steeringConfig;
      return quantizeAngle(candidate, min, max, step);
    };

    const applySteeringInputs = (values) => {
      if (!steeringConfig) {
        return;
      }
      const precision = steeringConfig.precision ?? 1;
      if (steeringLeft) {
        steeringLeft.value = formatAngleInput(values.left, precision);
      }
      if (steeringMid) {
        steeringMid.value = formatAngleInput(values.mid, precision);
      }
      if (steeringRight) {
        steeringRight.value = formatAngleInput(values.right, precision);
      }
    };

    const revertSteeringInputs = () => {
      if (!steeringConfig || !steeringConfig.values) {
        steeringInputs.forEach((input) => {
          input.value = '';
        });
        return;
      }
      applySteeringInputs(steeringConfig.values);
    };

    const syncSteeringAngles = (info) => {
      if (steeringInputs.length === 0) {
        return null;
      }
      if (
        !info ||
        !Number.isFinite(info.left) ||
        !Number.isFinite(info.mid) ||
        !Number.isFinite(info.right)
      ) {
        steeringConfig = null;
        steeringInputs.forEach((input) => {
          input.disabled = true;
          input.value = '';
        });
        return null;
      }
      const min = Number.isFinite(info.min) ? info.min : 0;
      const max = Number.isFinite(info.max) ? info.max : 270;
      const step = Number.isFinite(info.step) && info.step > 0 ? info.step : 0.5;
      const precision = determineAnglePrecision(step);
      const left = quantizeAngle(info.left, min, max, step);
      const mid = quantizeAngle(info.mid, min, max, step);
      const right = quantizeAngle(info.right, min, max, step);
      if (left === null || mid === null || right === null || !(left <= mid && mid <= right)) {
        steeringConfig = null;
        steeringInputs.forEach((input) => {
          input.disabled = true;
          input.value = '';
        });
        return null;
      }
      steeringConfig = {
        min,
        max,
        step,
        precision,
        values: { left, mid, right },
      };
      steeringInputs.forEach((input) => {
        input.disabled = false;
        input.min = String(min);
        input.max = String(max);
        input.step = String(step);
      });
      applySteeringInputs(steeringConfig.values);
      return steeringConfig.values;
    };

    const getCurrentSteeringValues = () => {
      if (!steeringConfig) {
        return null;
      }
      const left = clampSteeringValue(steeringLeft?.value);
      const mid = clampSteeringValue(steeringMid?.value);
      const right = clampSteeringValue(steeringRight?.value);
      if (left === null || mid === null || right === null) {
        return null;
      }
      if (!(left <= mid && mid <= right)) {
        return null;
      }
      return { left, mid, right };
    };

    const clampHeadValue = (rawValue) => {
      if (!headConfig) {
        return null;
      }
      if (rawValue === undefined || rawValue === null) {
        return null;
      }
      let candidate = rawValue;
      if (typeof candidate === 'string') {
        candidate = candidate.trim();
        if (candidate === '') {
          return null;
        }
        candidate = candidate.replace(',', '.');
      }
      const { min, max, step } = headConfig;
      return quantizeAngle(candidate, min, max, step);
    };

    const applyHeadInputs = (values) => {
      if (!headConfig) {
        return;
      }
      const precision = headConfig.precision ?? 1;
      if (headLeft) {
        headLeft.value = formatAngleInput(values.left, precision);
      }
      if (headMid) {
        headMid.value = formatAngleInput(values.mid, precision);
      }
      if (headRight) {
        headRight.value = formatAngleInput(values.right, precision);
      }
    };

    const revertHeadInputs = () => {
      if (!headConfig || !headConfig.values) {
        headInputs.forEach((input) => {
          input.value = '';
        });
        return;
      }
      applyHeadInputs(headConfig.values);
    };

    const syncHeadAngles = (info) => {
      if (headInputs.length === 0) {
        return null;
      }
      if (
        !info ||
        !Number.isFinite(info.left) ||
        !Number.isFinite(info.mid) ||
        !Number.isFinite(info.right)
      ) {
        headConfig = null;
        headInputs.forEach((input) => {
          input.disabled = true;
          input.value = '';
        });
        return null;
      }
      const min = Number.isFinite(info.min) ? info.min : 0;
      const max = Number.isFinite(info.max) ? info.max : 270;
      const step = Number.isFinite(info.step) && info.step > 0 ? info.step : 0.5;
      const precision = determineAnglePrecision(step);
      const left = quantizeAngle(info.left, min, max, step);
      const mid = quantizeAngle(info.mid, min, max, step);
      const right = quantizeAngle(info.right, min, max, step);
      if (left === null || mid === null || right === null || !(left <= mid && mid <= right)) {
        headConfig = null;
        headInputs.forEach((input) => {
          input.disabled = true;
          input.value = '';
        });
        return null;
      }
      headConfig = {
        min,
        max,
        step,
        precision,
        values: { left, mid, right },
      };
      headInputs.forEach((input) => {
        input.disabled = false;
        input.min = String(min);
        input.max = String(max);
        input.step = String(step);
      });
      applyHeadInputs(headConfig.values);
      return headConfig.values;
    };

    const getCurrentHeadValues = () => {
      if (!headConfig) {
        return null;
      }
      const left = clampHeadValue(headLeft?.value);
      const mid = clampHeadValue(headMid?.value);
      const right = clampHeadValue(headRight?.value);
      if (left === null || mid === null || right === null) {
        return null;
      }
      if (!(left <= mid && mid <= right)) {
        return null;
      }
      return { left, mid, right };
    };

    async function loadAdvancedSettings() {
      try {
        setStatus('Lade Einstellungen …');
        const resp = await fetch('/api/state');
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        const motorValues = syncMotorLimits(data.motor_limits);
        const steeringValues = syncSteeringAngles(data.steering_angles);
        const headValues = syncHeadAngles(data.head_angles);
        const loadedSections = [];
        if (motorValues) {
          loadedSections.push('Motor-Grenzen');
        }
        if (steeringValues) {
          loadedSections.push('Lenkwinkel');
        }
        if (headValues) {
          loadedSections.push('Kopfwinkel');
        }
        const statusMessage = formatLoadedStatus(loadedSections);
        if (statusMessage) {
          setStatus(statusMessage, 'success');
        } else {
          setStatus('Keine erweiterten Einstellungen verfügbar.', 'error');
        }
      } catch (err) {
        console.error('Laden der erweiterten Einstellungen fehlgeschlagen', err);
        setStatus('Erweiterte Einstellungen konnten nicht geladen werden.', 'error');
        syncMotorLimits(null);
        syncSteeringAngles(null);
        syncHeadAngles(null);
      }
    }

    async function saveMotorLimits(forward, reverse) {
      if (!motorForward || !motorReverse) {
        return;
      }
      try {
        setStatus('Speichere Motor-Grenzen …');
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ motor_limits: { forward, reverse } })
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        syncSteeringAngles(data.steering_angles);
        syncHeadAngles(data.head_angles);
        const updated = syncMotorLimits(data.motor_limits);
        if (updated) {
          setStatus('Motor-Grenzen gespeichert.', 'success');
        } else {
          setStatus('Motor-Grenzen konnten nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern der Motor-Grenzen fehlgeschlagen', err);
        setStatus('Motor-Grenzen konnten nicht gespeichert werden.', 'error');
      }
    }

    async function saveSteeringAngles(values) {
      if (!values) {
        return;
      }
      try {
        setStatus('Speichere Lenkwinkel …');
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ steering_angles: values })
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        const updated = syncSteeringAngles(data.steering_angles);
        syncMotorLimits(data.motor_limits);
        syncHeadAngles(data.head_angles);
        if (updated) {
          setStatus('Lenkwinkel gespeichert.', 'success');
        } else {
          setStatus('Lenkwinkel konnten nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern der Lenkwinkel fehlgeschlagen', err);
        revertSteeringInputs();
        setStatus('Lenkwinkel konnten nicht gespeichert werden.', 'error');
      }
    }

    async function saveHeadAngles(values) {
      if (!values) {
        return;
      }
      try {
        setStatus('Speichere Kopfwinkel …');
        const resp = await fetch('/api/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ head_angles: values })
        });
        if (!resp.ok) {
          throw new Error(`Status ${resp.status}`);
        }
        const data = await resp.json();
        const updated = syncHeadAngles(data.head_angles);
        syncMotorLimits(data.motor_limits);
        syncSteeringAngles(data.steering_angles);
        if (updated) {
          setStatus('Kopfwinkel gespeichert.', 'success');
        } else {
          setStatus('Kopfwinkel konnten nicht gespeichert werden.', 'error');
        }
      } catch (err) {
        console.error('Speichern der Kopfwinkel fehlgeschlagen', err);
        revertHeadInputs();
        setStatus('Kopfwinkel konnten nicht gespeichert werden.', 'error');
      }
    }

    if (steeringInputs.length > 0) {
      steeringInputs.forEach((input) => {
        input.disabled = true;
        input.value = '';
      });
    }

    if (headInputs.length > 0) {
      headInputs.forEach((input) => {
        input.disabled = true;
        input.value = '';
      });
    }

    if (motorForward) {
      motorForward.disabled = true;
      motorForward.value = '0';
    }
    if (motorReverse) {
      motorReverse.disabled = true;
      motorReverse.value = '0';
    }
    if (motorForwardValue) {
      motorForwardValue.textContent = '–';
    }
    if (motorReverseValue) {
      motorReverseValue.textContent = '–';
    }

    if (motorForward && motorForwardValue) {
      motorForward.addEventListener('input', () => {
        const value = clampMotorFromSlider(motorForward.value);
        motorForwardValue.textContent = value === null ? '–' : formatMotorPercent(value);
      });
      motorForward.addEventListener('change', () => {
        const values = getCurrentMotorValues();
        if (!values) {
          return;
        }
        motorForward.value = String(Math.round(values.forward * 100));
        motorForwardValue.textContent = formatMotorPercent(values.forward);
        motorReverse.value = String(Math.round(values.reverse * 100));
        motorReverseValue.textContent = formatMotorPercent(values.reverse);
        saveMotorLimits(values.forward, values.reverse);
      });
    }

    if (motorReverse && motorReverseValue) {
      motorReverse.addEventListener('input', () => {
        const value = clampMotorFromSlider(motorReverse.value);
        motorReverseValue.textContent = value === null ? '–' : formatMotorPercent(value);
      });
      motorReverse.addEventListener('change', () => {
        const values = getCurrentMotorValues();
        if (!values) {
          return;
        }
        motorForward.value = String(Math.round(values.forward * 100));
        motorForwardValue.textContent = formatMotorPercent(values.forward);
        motorReverse.value = String(Math.round(values.reverse * 100));
        motorReverseValue.textContent = formatMotorPercent(values.reverse);
        saveMotorLimits(values.forward, values.reverse);
      });
    }

    if (steeringInputs.length > 0) {
      const handleSteeringChange = () => {
        const values = getCurrentSteeringValues();
        if (!values) {
          setStatus('Ungültige Lenkwinkel. Bitte Werte prüfen.', 'error');
          revertSteeringInputs();
          return;
        }
        if (
          steeringConfig &&
          steeringConfig.values &&
          values.left === steeringConfig.values.left &&
          values.mid === steeringConfig.values.mid &&
          values.right === steeringConfig.values.right
        ) {
          applySteeringInputs(steeringConfig.values);
          return;
        }
        applySteeringInputs(values);
        saveSteeringAngles(values);
      };
      steeringInputs.forEach((input) => {
        input.addEventListener('input', () => {
          if (!steeringConfig) {
            return;
          }
          const raw = input.value;
          if (raw === undefined || raw === null) {
            return;
          }
          const normalized = String(raw).trim();
          if (
            normalized === '' ||
            normalized.endsWith('.') ||
            normalized.endsWith(',') ||
            normalized === '-' ||
            normalized === '+'
          ) {
            return;
          }
          const value = clampSteeringValue(normalized);
          if (value === null) {
            return;
          }
          const formatted = formatAngleInput(value, steeringConfig.precision);
          if (formatted !== raw) {
            input.value = formatted;
          }
        });
        input.addEventListener('change', handleSteeringChange);
      });
    }

    if (headInputs.length > 0) {
      const handleHeadChange = () => {
        const values = getCurrentHeadValues();
        if (!values) {
          setStatus('Ungültige Kopfwinkel. Bitte Werte prüfen.', 'error');
          revertHeadInputs();
          return;
        }
        if (
          headConfig &&
          headConfig.values &&
          values.left === headConfig.values.left &&
          values.mid === headConfig.values.mid &&
          values.right === headConfig.values.right
        ) {
          applyHeadInputs(headConfig.values);
          return;
        }
        applyHeadInputs(values);
        saveHeadAngles(values);
      };
      headInputs.forEach((input) => {
        input.addEventListener('input', () => {
          if (!headConfig) {
            return;
          }
          const raw = input.value;
          if (raw === undefined || raw === null) {
            return;
          }
          const normalized = String(raw).trim();
          if (
            normalized === '' ||
            normalized.endsWith('.') ||
            normalized.endsWith(',') ||
            normalized === '-' ||
            normalized === '+'
          ) {
            return;
          }
          const value = clampHeadValue(normalized);
          if (value === null) {
            return;
          }
          const formatted = formatAngleInput(value, headConfig.precision);
          if (formatted !== raw) {
            input.value = formatted;
          }
        });
        input.addEventListener('change', handleHeadChange);
      });
    }

    loadAdvancedSettings();
  </script>
</body>
</html>
